\documentclass{beamer}
\usepackage{fp}

\title{Функции от по-висок ред}

\date{28 октомври 2015 г.}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section{Функциите като параметри}

\begin{frame}[fragile]
  \frametitle{Подаване на функции като параметри}

  В Scheme функциите са ``първокласни'' стойности.
  \vspace{1em}

  \pause

  Примери:
  \begin{itemize}[<+->]
  \item \verb#(define (fixed-point? f x) (= (f x) x))#
  \item \evalstop{(fixed-point? sin 0)}{\#t}
  \item \evalstop{(fixed-point? exp 1)}{\#f}
  \item \evalstoerrp{(fixed-point? + 0)}
  \item \alt<17>{\tt{(define (branch p? f g x) ((if (p? x) f g) x))}}
    {\tt{(define (branch p? f g x) (if (p? x) (f x) (g x)))}}
  \item \evalstop{(branch odd? exp fact 4)}{24}
  \item \verb#(define (id x) x)#
  \item \evalstop{(branch number? log id "1")}{"1"}
  \item \evalstop{(branch string? number? procedure? symbol?)}{\#t}
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Функции от по-висок ред}

  \begin{definition}
    Функция, която приема функция за параметър се нарича \emph{функция от по-висок ред}.
  \end{definition}

  \pause

  \begin{itemize}[<+->]
  \item \tt{fixed-point?} и \tt{branch} са функции от по-висок ред
  \item \alert{Примери за математически функции от по-висок ред?}
  \item Всички функции в $\lambda$-смятането са от по-висок ред!
  \end{itemize}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Задачи за сумиране}

  \textbf{Задача:} Да се пресметнат следните суми:
  \begin{enumerate}
  \item $k^2 + (k+1)^2 + \ldots + 100^2$ за $k \leq 100$
  \item $\int_a^b f(x) \approx \Delta x\big[f(a) + f(a+\Delta x) + f(a+2\Delta x) + \ldots + f(b)\big]$
  \item $x + e^x + e^{e^x} + e^{e^{e^x}} + \ldots$ докато поредното събираемо е $\leq 10^{1000}$
  \end{enumerate}

  \pause

  \newcommand{\upper}{\textcolor<5->{red}}
  \newcommand{\term}{\textcolor<6->{green}}
  \newcommand{\next}{\textcolor<7->{blue}}

\begin{semiverbatim}
(define (sum1 k)
  (if (> k \upper{100}) 0 (+ \term{(* k k)} (sum1 \next{(+ k 1)}))))
\end{semiverbatim}

  \pause

\begin{semiverbatim}
(define (sum2 a b f dx)
  (if (> a \upper{b}) 0 (+ \term{(* dx (f a))} (sum2 \next{(+ a dx)} b f dx))))
\end{semiverbatim}

  \pause

\begin{semiverbatim}
(define (sum3 x)
  (if (> x \upper{(expt 10 1000)}) 0 (+ \term{x} (sum3 \next{(exp x)}))))
\end{semiverbatim}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Обобщена функция за сумиране}
  Да се напише функция от по-висок ред \tt{sum}, която пресмята сумата:

  \begin{equation*}
    \sum_{\substack{i=a \\i \leftarrow next(i)}}^b term(i).
  \end{equation*}

\pause

\begin{semiverbatim}
(define (sum a \textcolor{red}b \textcolor{green}{term} \textcolor{blue}{next})
  (if (> a \textcolor{red}b) 0 (+ \textcolor{green}{(term a)} (sum \textcolor{blue}{(next a)} \textcolor{red}b \textcolor{green}{term} \textcolor{blue}{next}))))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Приложения на \tt{sum}}

  Решение на задачите за суми чрез \tt{sum}:

  \begin{columns}[t,onlytextwidth]
    \column{0.3\textwidth}

    \begin{equation*}
      \sum_{i=k}^{100} i^2
    \end{equation*}

    \only<3->{
    \begin{equation*}
      \sum_{\substack{i=a\\i\rightarrow i + \Delta x}}^b \Delta x\,f(i)
    \end{equation*}}

    \only<6->{
    \begin{equation*}
      \sum_{\substack{i=x\\i\rightarrow e^i}}^{10^{1000}} i
    \end{equation*}}

    \column{0.7\textwidth}

\onslide<2->
\begin{verbatim}
(define (square x) (* x x))
(define (1+ x) (+ x 1))
(define (sum1 k) (sum k 100 square 1+))
\end{verbatim}

\onslide<4->
\begin{semiverbatim}
(define (sum2 a b f dx)
\only<4>{  (define (term x) (* dx (f x)))
}  (define (next x) (+ x dx))
  \only<5->{(* dx }(sum a b \alt<4>{term}f next))\only<5->)
\end{semiverbatim}

\onslide<7->
\begin{verbatim}
(define (sum3 x)
  (sum x (expt 10 1000) id exp))
\end{verbatim}

  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Обобщена функция за произведение}
  Да се напише функция от по-висок ред \tt{product}, която пресмята:

  \begin{equation*}
    \prod_{\substack{i=a \\i \leftarrow next(i)}}^b term(i).
  \end{equation*}

\pause

\newcommand{\fb}{\only<4>\fbox}

\begin{semiverbatim}
(define (product a \textcolor{red}b \textcolor{green}{term} \textcolor{blue}{next})
  (if (> a \textcolor{red}b) \fb1 (\fb* \textcolor{green}{(term a)} (product \textcolor{blue}{(next a)} \textcolor{red}b \textcolor{green}{term} \textcolor{blue}{next}))))
\end{semiverbatim}

\pause

\begin{semiverbatim}
(define (sum a \textcolor{red}b \textcolor{green}{term} \textcolor{blue}{next})
  (if (> a \textcolor{red}b) \fb0 (\fb+ \textcolor{green}{(term a)} (sum \textcolor{blue}{(next a)} \textcolor{red}b \textcolor{green}{term} \textcolor{blue}{next}))))
\end{semiverbatim}

\end{frame}

\section{\tt{accumulate}}

\subsection{Дясно натрупване}

\begin{frame}[fragile]
  \frametitle{Обобщена функция за натрупване}

  Да се напише функция, която пресмята

  \begin{equation*}
    term(a) \oplus \bigg(term\big(next(a)\big) \oplus \Big(\ldots \oplus \big(term(b) \oplus \bot\big) \ldots\Big)\bigg),
  \end{equation*}

  където $\oplus$ е бинарна операция,\\
  а $\bot$ е нейната ``нулева стойност'', т.е. $x\oplus\bot = x$.

  \pause
\small
\begin{verbatim}
(define (accumulate op nv a b term next)
  (if (> a b) nv
      (op (term a) (accumulate op nv (next a) b term next))))
\end{verbatim}
\pause
\begin{verbatim}
(define (sum a b term next) (accumulate + 0 a b term next))
(define (product a b term next) (accumulate * 1 a b term next))
\end{verbatim}
\end{frame}

\subsection{Пример: правило на Хорнер}

\newcommand{\pnx}{x^n + 2x^{n-1} + \ldots + (n-2)x^3 + (n-1)x^2 + nx + (n+1)}

\begin{frame}[fragile]
  \frametitle{Задача: пресмятане на полином}

  Да се пресметне стойността на полинома

  \begin{eqnarray*}
  P_n(x) &=& \pnx\\
\pause   &=& \sum_{i=0}^n (n+1-i)x^i
  \end{eqnarray*}
  \pause

  \textbf{Решение №1:}
\begin{semiverbatim}
(define (p n x)
\only<7->{  (define (term i) (* (- (1+ n) i) (expt x i)))
}  (accumulate \rvl+ \rvl0 \rvl0 \rvl{n} \rvl{term} \rvl{1+}))
\end{semiverbatim}

  \pause

  \vspace{1em}
  \alert{Можем ли да решим задачата без да извикваме \tt{expt} на всяка стъпка?}
\end{frame}

\newcommand{\pnxh}{\Bigg(\bigg(\Big(\ldots\big((x + 2)x + 3\big)x + \ldots\Big)x + (n-1)\bigg)x + n\Bigg)x + (n+1)}

\begin{frame}[fragile]
  \frametitle{Правило на Хорнер}

  \begin{equation*}
    P_n(x) = \pnxh
  \end{equation*}

  \pause

  \alert{Можем ли да сметнем с \tt{accumulate}?}

  \pause

  \textbf{Идея:} Да използваме операцията $a \oplus b := ax + b$.

  \pause

  \alert{Коя е ``нулевата стойност''  $\bot$?}
  \vspace{1em}

  \pause

  \textbf{Решение №2:}
\begin{verbatim}
(define (p n x)
  (define (op a b) (+ (* a x) b))
  (accumulate op 0 1 (1+ n) id 1+))
\end{verbatim}

  \pause

  \alert{Не смята правилно!}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Правило на Хорнер}

Всъщност пресметнахме:
\begin{equation*}
  Q_n(x) = x + 2x + 3x + \ldots + nx + (n+1)x= \frac{(n+1)(n+2)}2x.
\end{equation*}
  \pause
  \textbf{Идея:} Да използваме операцията $a \oplus b := a + bx$.
  \vspace{1em}
  \pause

  \textbf{Решение №3:}
\begin{semiverbatim}
(define (p n x)
  (define (op a b) (+ a (* b x)))
  (accumulate op 0 1 (1+ n) id 1+))
\end{semiverbatim}

  \pause

  \alert{Пак не смята правилно!!!}

\end{frame}

\begin{frame}
  \frametitle{Ляво и дясно натрупване}

  Всъщност пресметнахме:
  \begin{eqnarray*}
    R_n(x) &=& 1+x\bigg(2+x\Big(\ldots+x\Big((n-1)+x(n+x(n+1))\Big)\ldots\Big)\bigg)\\
          &=&  (n+1)x^n + nx^{n-1} + (n-1)x^{n-2} + \ldots + 3x^2 + 2x + 1
  \end{eqnarray*}
  вместо
  \begin{eqnarray*}
    P_n(x) &=& \pnxh\\
    &=& \pnx.
  \end{eqnarray*}

  \pause

  \alert{За неасоциативни  операции $\oplus$ има значение в какъв ред са скобите!}
\end{frame}

\subsection{Ляво натрупване}

\begin{frame}[fragile]
  \frametitle{Обобщена функция за натрупване}

  Да се напише функция, която пресмята \textbf{ляво натрупване}:

  \begin{equation*}
    (\ldots((\bot \oplus term(a)) \oplus term(next(a))) \oplus \ldots) \oplus term(b)
  \end{equation*}

  \pause
  \small
\begin{verbatim}
(define (accumulate-i op nv a b term next)
  (if (> a b) nv
      (accumulate-i op (op nv (term a)) (next a) b term next)))
\end{verbatim}

  \pause
  \begin{itemize}
  \item \tt{accumulate} --- дясно натрупване, рекурсивен процес
  \item \tt{accumulate-i} --- ляво натрупване, итеративен процес
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Правило на Хорнер}

  \begin{eqnarray*}
    P_n(x) &=& \pnx\\
    &=& \pnxh
  \end{eqnarray*}

  Идея: използваме \tt{accumulate-i} и $a \oplus b := ax + b$.
  \vspace{1em}
  \pause

  \textbf{Решение №4:}

\begin{verbatim}
(define (p n x)
  (define (op a b) (+ (* a x) b))
  (accumulate-i op 0 1 (1+ n) id 1+))
\end{verbatim}
\end{frame}

\section{\tt{lambda}}

\begin{frame}
  \frametitle{Анонимни функции}

  Можем ли да ги конструираме параметрите на функциите от по-висок ред ``на място'', без да им даваме имена?
  \vspace{0.5em}

  \pause
  \begin{itemize}[<+->]
  \item \tta{(lambda (}\{<параметър>\}\tta) <тяло>\tta)
  \item Оценява се до функционален обект със съответните параметри и тяло
  \item \alert{Анонимната функция пази указател към средата, в която е оценена}
  \item Примери:
    \begin{itemize}
    \item \evalsto{(lambda (x) (+ x 3))}{\#<procedure>}
    \item \evalsto{((lambda (x) (+ x 3)) 5)}8
    \item
        \tt{(define (}<име> <параметри>\tt) <тяло>\tt)\\
        $\longleftrightarrow$\\
        \tt{(define }<име> \tt{(lambda (}<параметри>\tt) <тяло>\tt{))}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Примери}

\begin{verbatim}
(define (integral a b f dx)
   (* dx (accumulate + 0 a b f (lambda (x) (+ x dx)))))
\end{verbatim}

\pause

\begin{verbatim}
(define (p n x)
   (accumulate-i + 0 1 (1+ n) (lambda (a b) (+ (* a x) b))
                              (lambda (i) (+ i 1))))
\end{verbatim}

\pause

Как можем да реализираме с accumulate:
\begin{itemize}
\item $n!$
\item $x^n$
\item $\sum_{i=0}^n \frac{x^n}{n!}$
\item $\exists x\in[a;b]\; p(x)$
\end{itemize}
\end{frame}

\section{Функциите като върнат резултат}

\begin{frame}
  \frametitle{Функции, които връщат функции}

  Да напишем функция, която прилага дадена функция два пъти над аргумент.

  \begin{itemize}[<+->]
  \item \tt{(define (twice f x) (f (f x)))}
  \item \evalstop{(twice square 3)}{81}
  \item \tt{(define (twice f) (lambda (x) (f (f x))))}
  \item \evalstoerrp{(twice square 3)}
  \item \evalstop{(twice square)}{\#<procedure>}
  \item \evalsto{((twice square) 3)}{81}
  \item \evalstop{((twice (twice square)) 2)}{65536}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Примери}

  \begin{itemize}[<+->]
  \item \tt{(define (n+ n) (lambda (i) (+ i n)))}
  \item \tt{(define 1+ (n+ 1))}
  \item \evalsto{(1+ 7)}8
  \item \tt{(define 5+ (n+ 5))}
  \item \evalsto{(5+ 7)}{12}
  \item \tt{(define (compose f g) (lambda (x) (f (g x))))}
  \item \evalstop{((compose square 1+) 3)}{16}
  \item \evalstop{((compose 1+ square) 3)}{10}
  \item \evalstop{((compose 1+ (compose square (n+ 2))) 3)}{26}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Оценка на \tt{lambda}}

  \scriptsize
  \begin{columns}[t,onlytextwidth]
    \column{0.5\textwidth}
    {}

    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{rc}
      \nxt{\inenv E&\tt{(define (n+ n)}\\
      &\tt{(lambda (i) (+ i n)))}\\
      \nxt{\inenv E&\tt{(define 1+ (n+ 1))}\\
      \nxt{\nxt{\inenv E&\tt{(define 5+ (n+ 5))}\\
      \nxt{\nxt{\inenv E&\tt{(1+ 7)}\\
      \nxt{&\bda\\
      \inenv{E_3}&\tt{(+ i n)}\\
      \nxt{&\bda\\
      &\tt 8}\\
      \nxt{\inenv E&\tt{(5+ 7)}\\
      \nxt{&\bda\\
      \inenv{E_4}&\tt{(+ i n)}\\
      \nxt{&\bda\\
      &\tt{12}
      }}}}}}}}}}
    \end{tabular}

    \column{0.5\textwidth}
    {}

    \begin{tabular}{cc}
      \multicolumn 2c{
      \begin{envir}E
        \\\firstinenv \tt{n+}&:&\funcenv{n}{($\lambda$(i) (+ i n)))}E
        \only<3->{\\\tt{1+}&:&\funcenv{i}{(+ i n)}{E_1}}
        \only<5->{\\\tt{5+}&:&\funcenv{i}{(+ i n)}{E_2}}
      \end{envir}}\\
      \only<2->\bua&
      \only<4->\bua\\
      \only<2->{
      \begin{envir}{E_1}
        \\\firstinenv \tt n&:&1
      \end{envir}}&
      \only<4->{
      \begin{envir}{E_2}
        \\\firstinenv \tt n&:&5
      \end{envir}}\\
      \only<7->\bua&
      \only<10->\bua\\
      \only<7->{
      \begin{envir}{E_3}
        \\\firstinenv \tt i&:&7
      \end{envir}}&
      \only<10->{
      \begin{envir}{E_4}
        \\\firstinenv \tt i&:&7
      \end{envir}}\\
    \end{tabular}
  \end{columns}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Намиране на производна}

  \begin{equation*}
    f'(x) \alt<1>{= \lim_{x\to\infty} \frac{f(x+\Delta x) - f(x)}{\Delta x}}{\approx\frac{f(x+\Delta x) - f(x)}{\Delta x}\;\text{ за малки }\Delta x}
  \end{equation*}

  \pause\pause

\begin{verbatim}
(define (derive f dx)
  (lambda (x) (/ (- (f (+ x dx)) (f x)) dx)))
\end{verbatim}
  \pause

  \begin{itemize}[<+->]
  \item \tt{(define 2* (derive square 0.01))}
  \item \evalsto{(2* 5)}{10.009999999999764}
  \item \evalsto{((derive square 0.0000001) 5)}{10.000000116860974}
  \item \evalstop{((derive (derive (lambda (x) (* x x x)) 0.001) 0.001) 3)}{18.006000004788802}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Повторено прилагане}

  Да се намери $n$-кратното прилагане на дадена функция.
  \begin{equation*}
    f^n(x) = \underbrace{f(f(f(\ldots(f}_n(x))\ldots)))
  \end{equation*}
  \pause
  \textbf{Решение №1:} $f^n(x) = f(f^{n-1}(x))$ \pause
\begin{verbatim}
(define (repeated f n)
  (lambda (x) (if (= n 0) x (f ((repeated f (- n 1)) x)))))
\end{verbatim}

  \pause

  \textbf{Решение №2:} $f^0 = id, f^n = f\circ f^{n-1}$ \pause
\begin{verbatim}
(define (repeated f n)
  (if (= n 0) id (compose f (repeated f (- n 1)))))
\end{verbatim}

  \pause

  \textbf{Решение №3:} $f^n = \underbrace{f \circ f \circ \ldots \circ f}_n \circ  id$ \pause
\begin{semiverbatim}
(define (repeated f n)
  (\rvl{accumulate} \rvl{compose} \rvl{id} \rvl1 \rvl{n} \rvl{(lambda (i) f)} \rvl{1+}))
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{$n$-та производна}

  Да се намери $n$-та производна на дадена функция.

  \vspace{1em}

  \pause

  \textbf{Решение №1:} $f^{(n)} = (f^{(n-1)})'$\pause
\begin{verbatim}
(define (derive-n f n dx)
  (if (= n 0) f (derive (derive-n f (- n 1) dx) dx)))
\end{verbatim}

  \pause

  \textbf{Решение №2:} $f^{(n)} = f\overbrace{''\ldots'}^n$\pause
\begin{semiverbatim}
(define (derive-n f n dx)
  \only<7->((\rvl{repeated} \rvl{(lambda (f) (derive f dx))} n)\only<7->{ f)})
\end{semiverbatim}
\end{frame}
\end{document}
\pause
  \textbf{Решение №3:} $^{(n)} = \underbrace{'^\circ'^{\circ\ldots\circ}'}_n$
\begin{semiverbatim}
(define (derive-n f n dx)
  ((\rvl{accumulate} \rvl{compose} \rvl{id} \rvl1 \rvl{n} \rvl{
              (lambda (i) (lambda (f) (derive f dx)))} \rvl{1+})) f)
\end{semiverbatim}
\end{frame}

\section{All you need is $\lambda$}

\begin{frame}
  \frametitle{All you need is $\lambda$ \only<2->{--- \tt{let}}}

  Специалната форма \tt{lambda} е достатъчна за реализацията на всички останали конструкции в Scheme!
  \vspace{1em}

  \pause

  Симулация на \tt{let}:
  \begin{tabular}{c}
    \tt{(let ((}<символ> <израз>\tt{))} <тяло>\tt)\\
    $\longleftrightarrow$\\
    \tt{((lambda (}<символ>\tt) <тяло>\tt{) <израз>)}
  \end{tabular}
  \vspace{1em}
  \pause

  \begin{center}
    \begin{tabular}{r@{}l}
      \tt{(let (}&\tt(<символ$_1$> <израз$_1$>\tt)\\
                 &\tt(<символ$_2$> <израз$_2$>\tt)\\
                 &\ldots\\
                 &\tt(<символ$_n$> <израз$_n$>\tt)\\
                 &<тяло>\tt)\\
      \multicolumn 2c{$\longleftrightarrow$}\\
      \tt{((lambda (}&<символ$_1$> \ldots <символ$_n$>\tt) <тяло>\tt)\\
                 &<израз$_1$> \ldots <израз$_n$>\tt)
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{All you need is $\lambda$ --- булева логика}

Симулация на булеви стойности и \tt{if}:

\begin{semiverbatim}
(define #t (lambda (x y) x))
(define #f (lambda (x y) y))
(define (lambda-if b x y) \only<2->((b x y)\only<2->))
\end{semiverbatim}
\pause\pause
Примери:

\small
\begin{itemize}[<+->]
\item \evalsto{(lambda-if \#t (lambda () (+ 3 5)) (lambda () (/ 4 0)))}8
\item \evalsto{(lambda-if \#f (lambda () +) (lambda () "abc"))}{"abc"}
\item \tt{(define (not b) (lambda (x y) (b y x)))}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{All you need is $\lambda$ --- числа}

  Симулация на естествени числа (\emph{нумерали на Чърч})

  Идея: представяне на числото $n$ като $\lambda f,x \;f^n(x)$
  \vspace{1em}
  \pause

  \begin{itemize}[<+->]
  \item \tt{(define c3 (lambda (f x) (f (f (f x)))))}
  \item \tt{(define c5 (lambda (f x) (f (f (f (f (f x)))))))}
  \item \tt{(define c1+ (lambda (a) (lambda (f x) (f (a f x)))))}
  \item \tt{(define c+ (lambda (a b) (lambda (f x) (a f (b f x)))))}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{All you need is $\lambda$ --- рекурсия}

  Комбинатор \tt Y за намиране на най-малка неподвижна точка (fixpoint combinator)

\begin{verbatim}
(define Y (lambda (f)
           ((lambda (x) (f (lambda (n) ((x x) n))))
            (lambda (x) (f (lambda (n) ((x x) n)))))))
\end{verbatim}

\pause

\begin{verbatim}
(define fact-body (lambda (f)
                   (lambda (n) (if (= n 0) 1
                                   (* n (f (- n 1)))))))
(define fact (Y fact-body))
\end{verbatim}
\end{frame}

\end{document}
