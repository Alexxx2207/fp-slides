\documentclass{beamer}
\usepackage{fprog}

\title{Кортежи и списъци}

\date{6--7 януари 2016 г.}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section{Кортежи}

\begin{frame}
  \frametitle{Кортежи (tuples)}
  Кортежите са наредени $n$-торки от данни от произволен тип.
  \begin{itemize}[<+->]
  \item Примери: \tt{(1, 2)}, \tt{(3.5,'A', False)}, \tt{(("square"{}, (\^{}2)), 1.0)}
  \item Тип кортеж от $n$ елемента: \tt{(t$_1$, t$_2$, \ldots, t$_n$)}
  \item Стойности: наредени $n$-торки от вида \tt{(x$_1$, x$_2$, \ldots, x$_n$)}, където \tt{x$_i$} е от тип \tt{t$_i$}
  \item Позволяват ``пакетиране"' на няколко стойности в една
  \item Операции за наредени двойки:
    \begin{itemize}
    \item \tt{(,) :: a -> b -> (a,b)} --- конструиране на наредена двойка
    \item \tt{fst :: (a,b) -> a} --- първа компонента на наредена двойка
    \item \tt{snd :: (a,b) -> b} --- втора компонента на наредена двойка
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Потребителски типове}
  \begin{itemize}[<+->]
  \item Типът \tt{(String, Int)} може да означава:
    \begin{itemize}
    \item име и ЕГН на човек
    \item продукт с описание и количество
    \item сонет на Шекспир и поредния му номер
    \end{itemize}
  \item Удобно е да именуваме типовете, за да означаваме смисъла им
  \item \tta{type }<конструктор> \tta= <тип>
    \begin{itemize}
    \item конструкторите са идентификатори, започващи с главна буква
    \end{itemize}
  \item Примери:
    \begin{itemize}
    \item \tt{type Student = (String, Int, Double)}
    \item \tt{type Point = (Double, Double)}
    \item \tt{type Triangle = (Point, Point, Point)}
    \item \tt{type Translation = Point -> Point}
    \item \tt{type Vector = Point}
    \item \tt{addVectors :: Vector -> Vector -> Vector}
    \item<.-> \tt{addVectors v1 v2 = (fst v1 + fst v2, snd v1 + snd v2)}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Особености на кортежите}
  \begin{itemize}[<+->]
  \item \evalstoerrp{fst (1,2,3)}
    \begin{itemize}
    \item \tt{fst} и \tt{snd} работят само над наредени двойки!
    \end{itemize}
  \item \tt{((a,b),c)} $\neq$ \tt{(a,(b,c))} $\neq$ \tt{(a,b,c)}
  \item Няма специален тип кортеж от един елемент\ldots
  \item \ldots но има тип ``празен кортеж'' \tt{()} с единствен елемент \tt{()}
    \begin{itemize}
    \item в други езици такъв тип се нарича \tt{unit}
    \item използва се за означаване на липса на информация
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Образци на кортежи}
  Образец на кортеж е конструкция от вида \tt{(p$_1$, p$_2$, \ldots, p$_n$)}.\\\pause
  Пасва на всеки кортеж от точно $n$ елемента \tt{(x$_1$, x$_2$, \ldots, x$_n$)}, за който образецът \tt{p$_i$} пасва на елемента \tt{x$_i$}.
  \onslide<+->
  \begin{itemize}[<+->]
  \item \verb#addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)#
  \item \verb#fst (x,_) = x#
  \item<.-> \verb#snd (_,y) = y#
  \item \verb#getFN :: Student -> Int#
  \item<.-> \verb#getFN (_, fn, _) = fn#
  \item образците на кортежи могат да се използват за ``разглобяване'' на кортежи при дефиниция
  \item \verb#(x,y) = (3.5, 7.8)#
  \item \verb#let (_, fn, grade) = student in (fn, min (grade + 1) 6)#
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Именувани образци}
  \begin{itemize}[<+->]
  \item намиране на студент с по-висока оценка
\begin{semiverbatim}
betterStudent (name1, fn1, grade1) (name2, fn2, grade2)
 | grade1 > grade2 = (name1, fn1, grade1)
 | otherwise       = (name2, fn2, grade2)
\end{semiverbatim}
  \item ами ако имахме 10 полета?
  \item удобно е да използваме \alert{именувани образци}
  \item{} <име>\tta@<образец> \onslide<+->
\begin{semiverbatim}
betterStudent s1@(_, _, grade1) s2@(_, _, grade2)
 | grade1 > grade2 = s1
 | otherwise       = s2
\end{semiverbatim}
  \end{itemize}
\end{frame}

\section{Списъци}

\subsection{Дефиниция и синтаксис}


\begin{frame}
  \frametitle{Списъци}

  \begin{definition}
    \begin{enumerate}
    \item Празният списък \tt{[]} е списък от тип \tt{[a]}
    \item Ако \tt h е елемент от тип \tt a и \tt t е списък от тип \tt{[a]} то \tt{(h : t)} е списък от тип \tt{[a]}
      \begin{itemize}
      \item \tt h --- глава на списъка
      \item \tt t --- опашка на списъка
      \end{itemize}
    \end{enumerate}
  \end{definition}
  \onslide<+->
  \begin{itemize}[<+->]
  \item списъкът е последователност с \alert{произволна дължина} от елементи от \alert{еднакъв тип}
  \item \tt{(:) :: a -> [a] -> [a]}  е \alert{дясноасоциативна} бинарна операция
  \item \tt{(1:(2:(3:(4:[]))))} $=$ \tt{1:2:3:4:[]} $\neq$ \tta{((((1:2):3):4):[])}
  \item \tt{[a$_1$, a$_2$, \ldots, a$_n$]} e по-удобен запис за \tt{a$_1$:(a$_2$:\ldots(a$_n$:[])\ldots)}
  \item \tt{[1,2,3,4]} $=$ \tt{1:[2,3,4]} $=$ \tt{1:2:[3,4]} $=$ \tt{1:2:3:[4]} $=$ \tt{1:2:3:4:[]}\
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Примери}
  \begin{itemize}[<+->]
  \item \typestop{[False]}{[Bool]}
  \item \ntypesp{["Иван"{}, 4.5]}
  \item \ntypesp{[1]:2}
  \item \typestop{[[1,2],[3],[4,5,6]]}{[[Int]]}
  \item \typestop{([1,2],[3],[4,5,6])}{([Int],[Int],[Int])}
  \item \ntypesp{[(1,2),(3),(4,5,6)]}
  \item \typestop{((1,2),(3),(4,5,6))}{((Int,Int),Int,(Int,Int,Int))}
  \item \typestop{[[]]}{[[a]]}
  \item \typestop{[]:[]}{[[a]]}
  \item \typestop{[1]:[[]]}{[[Int]]}
  \item \ntypesp{[]:[1]}
  \item \typestop{[[1,2,3],[]]}{[[Int]]}
  \item \ntypesp{[[1,2,3],[[]]]}
  \item \typestop{[1,2,3]:[4,5,6]:[[]]}{[[Int]]}
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Низове}

  \begin{itemize}[<+->]
  \item В Haskell низовете са представени като списъци от символи
  \item \tt{type String = [Char]}
  \item Всички операции над списъци важат и над низове
  \item Примери
    \begin{itemize}
    \item \tt{['H', 'e', 'l', 'l', 'o' ]} = \tt{"Hello"}
    \item \tt{'H':'e':'l':'l':'o':[]} = \tt{"Hello"}
    \item \tt{'H':'e':"llo"} = \tt{"Hello"}
    \item \tt{"{}"} = \tt{[] :: [Char]}
    \item \ntypesp{[[1,2,3],{}"{}"]}
    \item \typestop{["12"{},['3'],[]]}{[String]}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Основни функции за списъци}
  % head, tail, null, length
  \begin{itemize}[<+->]
  \item \tt{head :: [a] -> a} --- връща главата на (непразен) списък
    \begin{itemize}
    \item \evalstop{head [[1,2],[3,4]]}{[1,2]}
    \item \evalstoerr{head []}
    \end{itemize}
  \item \tt{tail :: [a] -> [a]} --- връща опашката на (непразен) списък
    \begin{itemize}
    \item \evalstop{tail [[1,2],[3,4]]}{[[3,4]]}
    \item \evalstoerr{tail []}
    \end{itemize}
  \item \tt{null :: [a] -> Bool} --- проверява дали списък е празен
  \item \tt{length :: [a] -> Int} --- дължина на списък
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Генератори на списъци}
  Можем да генерираме списъци от последователни елементи
  \begin{itemize}
  \item \tta[from\tta{..}to\tta] $\rightarrow$ \tta[from\tta, from+1\tta, from+2\tta,\ldots to\tta]
  \item Пример: \evalsto{[1..5]}{[1,2,3,4,5]}
  \item Пример: \evalsto{['a'..'e']}{"abcde"}
  \item Синтактична захар за \tt{enumFromTo from to}
    \pause
  \item \tta[from\tta,from+inc\tta{..}to\tta] $\rightarrow$ \tta[from\tta, from+inc\tta, from+2.inc\tta,\ldots to'\tta], където to' е най-голямото число $\leq$ to, за което to' = from+k.inc
  \item Пример: \evalsto{[1,4..15]}{[1,4,7,10,13]}
  \item Пример: \evalsto{['a','e'..'z']}{"aeimquy"}
  \item Синтактична захар за \tt{enumFromThenTo from then to}
  \end{itemize}
\end{frame}

\subsection{Работа със списъци}

\begin{frame}[fragile]
  \frametitle{Рекурсивни функции над списъци}
  \begin{itemize}[<+->]
  \item \tt{(++) :: [a] -> [a] -> [a]} --- слепва два списъка
    \begin{itemize}[<.->]
    \item  \evalsto{[1..3] ++ [5..7]}{[1,2,3,5,6,7]}
    \end{itemize}
  \item \verb#a ++ b = if null a then b else head a : tail a ++ b#
  \item \tt{reverse :: [a] -> [a]} ---  обръща списък
    \begin{itemize}[<.->]
    \item \evalsto{reverse [1..5]}{[5,4,3,2,1]}
    \end{itemize}
    \onslide<+->
\begin{semiverbatim}
reverse a
 | null a    = a
 | otherwise = reverse (tail a) ++ [head a]
\end{semiverbatim}
  \item \tt{(!!) :: [a] -> Int -> a} --- елемент с пореден номер (от 0)
    \begin{itemize}[<.->]
    \item \evalsto{"Haskell"{} !! 2}{'s'}
    \end{itemize}
  \item \tt{elem :: \alert{Eq a => }a -> [a] -> Bool} --- проверка за принадлежност на елемент към списък
    \begin{itemize}[<.->]
    \item \evalsto{3 `elem` [1..5]}{True}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Образци и списъци}

  Много удобно е да използваме образци на списъци:
  \begin{itemize}[<+->]
  \item \tt{p$_h$:p$_t$} --- пасва на всеки непразен списък \tt l, за който:
    \begin{itemize}
    \item образецът \tt{p$_h$} пасва на главата на \tt l
    \item образецът  \tt{p$_t$} пасва на опашката на \tt l
    \end{itemize}
  \item \alert{Внимание:} обикновено слагаме скоби \tt{(h:t)}, понеже операцията \tt: е с много нисък приоритет
  \item \tt{[p$_1$, p$_2$, \ldots, p$_n$]} --- пасва на всеки списък от точно $n$ елемента \tt{[x$_1$, x$_2$, \ldots, x$_n$]}, за който образецът \tt{p$_i$} пасва на елемента \tt{x$_i$}
  \item Примери:
    \begin{itemize}
    \item     \verb#head (h:_) = h#
    \item     \verb#tail (_:t) = t#
    \item     \verb#null [] = True#
    \item<.-> \verb#null _  = False#
    \item     \verb#length []    = 0#
    \item<.-> \verb#length (_:t) = 1 + length t#
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[label=current]
  \frametitle{Случаи по образци (\tt{case})}
  \begin{itemize}[<+->]
  \item \tta{case} <израз> \tta{of} \{ <образец> \tta{->} <израз> \}$^+$
  \item \begin{tabular}[t]{@{}l@{ }l}
          \tta{case} <израз> \tta{of}&<образец$_1$> \tta{->} <израз$_1$>\\
                                     &\ldots\\
                                     &<образец$_n$> \tta{->} <израз$_n$>
        \end{tabular}
  \item ако <израз> пасва на <образец$_1$>, връща <израз$_1$>, иначе:
  \item<.-> \ldots
  \item<.-> ако <израз> пасва на <образец$_n$>, връща <израз$_n$>, иначе:
  \item<.-> \alert{Грешка!}
  \item Използването на образци в дефиниции всъщност е синтактична захар за конструкцията \tt{case}!
  \item \tt{case} може да се използва навсякъде, където се очаква израз
  \end{itemize}
\end{frame}

\subsection{Полиморфизъм}

\begin{frame}
  \frametitle{Полиморфни функции}
  %++, !!, reverse, elem, notElem
  Функциите \tt{head}, \tt{tail}, \tt{null}, \tt{length}, \tt{reverse} и операциите \tt{++} и \tt{!!} са \textbf{полиморфни}
  \begin{itemize}[<+->]
  \item работят над списъци с елементи от произволен тип \tt{[a]}
  \item \tt a се нарича \textbf{типова променлива}
  \item свойството се нарича \textbf{параметричен типов полиморфизъм}
  \item подобно на шаблоните в C++
  \item \alert{да не се бърка с \textbf{подтипов полиморфизъм}, реализиран с виртуални функции!}
  \item \tt{[]} е \textbf{полиморфна константа}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Класове от типове (typeclasses)}
  Функцията \tt{elem} има специални изисквания към типа на елементите на списъка: трябва да могат да бъдат сравнявани с \tt{==} или \tt{/=}
  \begin{itemize}[<+->]
  \item \tt{elem :: \alert{Eq a => }a -> [a] -> Bool}
  \item \tt{Eq} е \alert{клас от типове}
  \item \tt{Eq} е класът на тези типове, за които има операции \tt{==} и \tt{/=}
    \begin{itemize}
    \item можем да си мислим за класовете от типове като за ``интерфейси''
    \end{itemize}
  \item \tt{Eq a} наричаме \alert{класово ограничение} за типа \tt a (class constraint)
  \item множеството от всички класови ограничения наричаме \alert{контекст}
  \item \alert{инстанция} на клас от типове наричаме всеки тип, за който са реализирани операциите зададени в класа
  \item инстанции на \tt{Eq} са:
    \begin{itemize}
    \item \tt{Bool}, \tt{Char}, всички числови типове (\tt{Int}, \tt{Integer}, \tt{Float}, \tt{Double})
    \item списъчните типове \tt{[a]}, за които \tt a е инстанция на \tt{Eq}
    \item кортежните типове \tt{(t$_1$,\ldots t$_n$)}, за които \tt{t$_i$} са инстанции на \tt{Eq}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Стандартни класове}
  Някои от по-често използваните класове на Haskell:
  \begin{itemize}[<+->]
  \item \tt{Eq} --- типове с равенство
  \item \tt{Ord} --- типове с (линейна) наредба
    \begin{itemize}[<.->]
    \item операциите \tt{==}, \tt{/=}, \tt{>=}, \tt{<=}, \tt{<}, \tt{>}
    \item специалната функция \tt{compare}, която сравнява два елемента и връща \tt{LT}, \tt{GT} или \tt{EQ} в зависимост от резултата
    \item функциите \tt{min} и \tt{max}
    \end{itemize}
  \item \tt{Show} --- типове, чиито елементи могат да бъдат извеждани в низ
    \begin{itemize}[<.->]
    \item функция \tt{show :: a -> String}
    \end{itemize}
  \item \tt{Read} --- типове, чиито елементи могат да бъдат въвеждани от низ
    \begin{itemize}[<.->]
    \item функция \tt{read :: String -> a}
    \end{itemize}
  \item \tt{Num} --- числови типове
  \item<.-> \tt{Integral} --- целочислени типове
  \item<.-> \tt{Floating} --- типове с плаваща запетая
  \item \alert{числата в Haskell са полиморфни константи!}
  \end{itemize}
\end{frame}

\subsection{Отделяне на списъци}

\begin{frame}
  \frametitle{Отделяне на списъци (list comprehension)}
  Отделянето на списъци е удобен начин за дефиниране на нови списъци чрез използване на дадени такива
  \begin{itemize}[<+->]
  \item \tta[ <израз> \tta| <генератор> \{\tta, <генератор>\} \{\tta, <условие>\} \tta]
  \item{} <генератор> е от вида <образец> \tta{<-} <израз>, където
    \begin{itemize}
    \item{} <израз> е от тип списък \tt{[a]}
    \item{} <образец> пасва на елементи от тип \tt a
    \end{itemize}
  \item{} <условие> е произволен израз от тип \tt{Bool}
  \item За всеки от елементите генериран от <генератор>, които удовлетворяват \alert{всички} <условие>, пресмята <израз> и натрупва резултатите в списък
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Примери за отделяне на списъци}

  \begin{itemize}[<+->]
  \item \evalstop{[ 2 * x | x <- [1..5] ]}{[2,4,6,8,10]}
  \item \evalstop{[ x\^{}2 | x <- [1..10], odd x]}{[1,9,25,49,81]}
  \item \tt{[ fn | (\_, fn, grade) <- students, grade >= 2 ]}
  \item \tt{[ x\^{}2 + y\^{}2 | (x, y) <- vectors, x >= 0, y >= 0]}
  \item Ако имаме повече от един генератор, се генерират всички възможни комбинации от елементи (декартово произведение)
  \item \evalstop{[ x++' ':y | x <- ["green"{},"blue"],y <- ["sky"{},"grass"]]}{["green sky"{},"green grass"{},"blue sky"{},"blue grass"]}
  \item \evalstop{[ (x,y) | x <- [1,2,3], y <- [5,6,7], x + y <= 8 ]\\}{[(1,5),(1,6),(1,7),(2,5),(2,6),(3,5)]}
  \item \textbf{Задача.} Да се генерират всички Питагорови тройки в даден интервал.
  \end{itemize}

\end{frame}

\section{Функции над списъци}

\begin{frame}
  \frametitle{Отрязване на списъци}
  \begin{itemize}
  \item \tt{init :: [a] -> [a]} --- списъка без последния му елемент
    \begin{itemize}
    \item \evalsto{init [1..5]}{[1,2,3,4]}
    \end{itemize}
  \item \tt{last :: [a] -> a} --- последния елемент на списъка
    \begin{itemize}
    \item \evalsto{last "Haskell"{}}l
    \end{itemize}
  \item \tt{take :: Int -> [a] -> [a]} --- първите $n$ елемента на списък
    \begin{itemize}
    \item \evalsto{take 4 "Hello, world!"{}}{"Hell"}
    \end{itemize}
  \item \tt{drop :: Int -> [a] -> [a]} --- списъка без първите $n$ елемента
    \begin{itemize}
    \item \evalsto{drop 2 [1,3..10]}{[5,7,9]}
    \end{itemize}
  \item \tt{splitAt :: Int -> [a] -> ([a],[a])}
    \begin{itemize}
    \item \tt{splitAt n l = (take n l, drop n l)}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Агрегиращи функции}
  % maximum, minimum, product, sum, and, or, concat
  \small
  \begin{itemize}
  \item \tt{maximum :: Ord a => [a] -> a} --- максимален елемент
  \item \tt{minimum :: Ord a => [a] -> a} --- минимален елемент
  \item \tt{sum :: Num a => [a] -> a} --- сума на списък от числа
  \item \tt{product :: Num a => [a] -> a} --- произведение на списък от числа
  \item \tt{and :: [Bool] -> Bool} --- конюнкция на булеви стойности
  \item \tt{or :: [Bool] -> Bool} --- дизюнкция на булеви стойности
  \item \tt{concat :: [[a]] -> [a]} --- конкатенация на списък от списъци
  \pause
  \item Примери:
    \begin{itemize}[<+->]
    \item \verb#[(sum l, product l)| l <- ll, maximum l == 2*minimum l]#
    \item \verb#and [ or [ mod x k == 0 | x <- row] | row <- matrix]#
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Функции от по-висок ред}
\begin{frame}
  \frametitle{$\lambda$-функции}  \begin{itemize}[<+->]
  \item \tta{\textbackslash}\{ <параметър> \}$^+$ \tta{->} <тяло>
  \item \tta{\textbackslash} <параметър$_1$> \ldots <параметър$_n$> \tta{->} <тяло>
  \item анонимна функция с $n$ параметъра
  \item всеки <параметър$_i$> всъщност е образец
  \item параметрите са видими само в рамките на <тяло>
  \item примери:
    \begin{itemize}
    \item \tt{id = \textbackslash x -> x}
    \item \tt{const = \textbackslash x y -> x}
    \item \evalsto{(\textbackslash x -> 2 * x + 1) 3}7
    \item \evalsto{(\textbackslash x l -> l ++ [x]) 4 [1..3]}{[1,2,3,4]}
    \item \evalsto{(\textbackslash (x,y) -> x\^{}2 + y) (3,5)}{14}
    \item \evalsto{(\textbackslash f x -> f (f x)) (*3) 4}{36}
    \end{itemize}
  \item отсичането на операции може да се изрази чрез $\lambda$-функции:
    \begin{itemize}
    \item \tt(<операция> <израз>\tt) = \tt{\textbackslash x -> x} <операция> <израз>
    \item \tt(<израз> <операция>\tt) = \tt{\textbackslash x ->}  <израз> <операция> \tt x
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Свойства на $\lambda$-функциите}
  \newcommand{\eqv}{$\longleftrightarrow$}
  \begin{itemize}[<+->]
  \item
    \begin{tabular}[t]{ll}
      &\tt{\textbackslash x$_1$ x$_2$ \ldots{} x$_n$ ->} <тяло>\\
      \eqv &\tt{\textbackslash x$_1$ -> \textbackslash x$_2$ -> \ldots{} \textbackslash x$_n$ ->}
             <тяло>
    \end{tabular}
  \item
    \begin{tabular}[t]{ll}
      &\tt{f x =} <тяло>\\
      \eqv&  \tt{f = \textbackslash x -> }<тяло>
    \end{tabular}
  \item
    \begin{tabular}[t]{ll}
      &\tt{f x y =} <тяло>\\
      \eqv& \tt{f x = \textbackslash y -> }<тяло>\\
      \eqv& \tt{f = \textbackslash x y -> }<тяло>
    \end{tabular}
  \item
    \begin{tabular}[t]{ll}
      &\tt{f x$_1$ \ldots x$_n$ =} <тяло>\\
      \eqv& \tt{f x$_1$ \ldots x$_{n-1}$ = \textbackslash x$_n$ ->} <тяло>\\
      \eqv& \ldots\\
      \eqv& \tt{f = \textbackslash x$_1$ \ldots x$_n$ -> }<тяло>
    \end{tabular}
  \item
    \begin{tabular}[t]{ll}
      &\tt{\textbackslash x y -> f x y}\\
      \eqv& \tt{\textbackslash x -> f x}\\
      \eqv& \tt f
    \end{tabular}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Трансформация (\tt{map})}
  \begin{itemize}[<+->]
  \item \tt{map :: (a -> b) -> [a] -> [b]}
  \item \tt{map f l = [ f x  | x <- l ]}
  \item \tt{map \_ [] = []}
  \item<.-> \tt{map f (x:xs) = f x : map f xs}
  \item Примери:
    \begin{itemize}
    \item \evalstop{map (\^{}2) [1,2,3]}{[1,4,9]}
    \item \evalstop{map (!!1) [[1,2,3],[4,5,6],[7,8,9]]}{[2,5,8]}
    \item \evalstop{map sum [[1,2,3],[4,5,6],[7,8,9]]}{[6,15,24]}
    \item \evalstop{map ("a "++) ["cat"{},"dog"{},"pig"]}{["a cat"{},"a dog"{},"a pig"]}
    \item \evalstop{map (\textbackslash f -> f 2) [(\^{}2),(1+),(*3)]}{[4,3,6]}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Филтриране (\tt{filter})}
  \begin{itemize}[<+->]
  \item \tt{filter :: (a -> Bool) -> [a] -> [a]}
  \item \tt{filter p l = [ x | x <- l, p x ]}
  \item
\begin{verbatim}
filter _ [] = []
filter p (x:xs)
 | p x       = x : rest
 | otherwise = rest
 where rest = filter p xs
\end{verbatim}
  \item Примери
    \begin{itemize}
    \item \evalstop{filter odd [1..5]}{[1,3,5]}
    \item \evalstop{filter (\textbackslash f -> f 2 > 3) [(\^{}2),(+1),(*3)]}{[(\^{}2),(*3)]}
    \item \evalstop{map (filter even) [[1,2,3],[4,5,6],[7,8,9]]}{[[2],[4,6],[8]]}
    \item \evalstop{map (\textbackslash x -> map (\textbackslash f -> filter f x) [(<0),(==0),(>0)]) [[-2,1,0],[1,4,-1],[0,0,1]]}{[[[-2],[0],[1]],[[-1],[],[1,4]],[[],[0,0],[1]]]}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Отделяне на списъци с \tt{map} и \tt{filter}}
  Отделянето на списъци е синтактична захар за \tt{map} и \tt{filter}\pause
  \small
  \begin{itemize}[<+->]
  \item \begin{tabular}[t]{l}
      \tt[<израз> \tt| <образец> \tt{<-} <списък>\tt, <условие>\tt]\\
      $\longleftrightarrow$\\
      \tt{map (\textbackslash}<образец> \tt{->} <израз>\tt)\\
      \hspace{5ex}\tt{(filter (\textbackslash}<образец> \tt{->} <условие>\tt) <списък>\tt)
    \end{tabular}
  \item \begin{tabular}[t]{l}
      \tt[<образец> \tt| <образец> \tt{<-} <списък>\tt,<условие$_1$>,<условие$_2$>\tt]\\
      $\longleftrightarrow$\\
      \tt{filter (\textbackslash}<образец> \tt{->} <условие$_2$>\tt)\\
      \hspace{5ex}\tt{(filter (\textbackslash}<образец> \tt{->} <условие$_1$>\tt) <списък>\tt)
    \end{tabular}
  \item \begin{tabular}[t]{l}
      \tt[<израз>\tt|<образец$_1$> \tt{<-} <списък$_1$>\tt,<образец$_2$> \tt{<-} <списък$_2$>\tt]\\
      $\longleftrightarrow$\\
      \tt{concat (map (\textbackslash}<образец$_1$> \tt{->}\\
      \hspace{15ex}\tt{map (\textbackslash} <образец$_2$> \tt{->} <израз>\tt) <списък$_2$>\tt)\\
      \hspace{10ex} <списък$_1$>\tt)
    \end{tabular}
  \end{itemize}
\end{frame}

\begin{frame}<1-14>[fragile]
  \frametitle{Дясно свиване (\tt{foldr})}
  \begin{itemize}[<+->]
  \item \tt{foldr :: (a -> b -> b) -> b -> [a] -> b}
  \item \tt{foldr op nv [x$_1$, x$_2$, \ldots, x$_n$]} = \\
    \tt{x$_1$ `op` (x$_2$ `op` \ldots (x$_n$ `op` nv) \ldots)}
  \item
\begin{verbatim}
foldr _  nv [] = nv
foldr op nv (x:xs) = x `op` foldr op nv xs
\end{verbatim}
  \item Примери
    \begin{itemize}
    \item \tt{sum = foldr (+) 0}
    \item \tt{product = foldr (*) 1}
    \item \tt{concat = foldr (++) []}
    \item \tt{and = foldr (\&\&) True}
    \item \tt{or = foldr (||) False}
    \item \tt{map f = foldr (\textbackslash x\only<-10>{ r} -> \alt<10>{f x : r}{(f x:)}) []}
      \onslide<+->
    \item \tt{filter p = foldr (\textbackslash x\only<-13>{ r} -> \temporal<13>{if p x then x : r else r}{(if p x then (x:) else id) r}{if p x then (x:) else id}) []}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ляво свиване (\tt{foldl})}
  \begin{itemize}[<+->]
  \item \tt{foldl :: (b -> a -> b) -> b -> [a] -> b}
  \item \tt{foldl op nv [x$_1$, x$_2$, \ldots, x$_n$]} = \\
    \tt{(\ldots((nv `op` x$_1$) `op` x$_2$) \ldots ) `op` x$_n$}
  \item
\begin{verbatim}
foldl _  nv [] = nv
foldl op nv (x:xs) = foldl op (nv `op` x) xs
\end{verbatim}
  \item Пример
    \begin{itemize}[<.->]
    \item \tt{flip f x y = f y x}
    \item \tt{reverse = foldl (flip (:)) []}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Свиване на непразни списъци (\tt{foldr1} и \tt{foldl1})}
  \begin{itemize}[<+->]
  \item \tt{foldr1 :: (a -> a -> a) -> [a] -> a}
  \item \tt{foldr1 op nv [x$_1$, x$_2$, \ldots, x$_n$]} = \\
    \tt{x$_1$ `op` (x$_2$ `op` \ldots (x$_{n-1}$ `op` x$_n$) \ldots)}
  \item
\begin{verbatim}
foldr1 _  [x] = x
foldr1 op (x:xs) = x `op` foldr1 op xs
\end{verbatim}
  \item \tt{foldl :: (a -> a -> a) -> [a] -> a}
  \item \tt{foldl op nv [x$_1$, x$_2$, \ldots, x$_n$]} = \\
    \tt{(\ldots((x$_1$ `op` x$_2$) \ldots ) `op` x$_n$}
  \item \tt{foldl1 op (x:xs) = foldl op x xs}
  \item Примери
    \begin{itemize}
    \item \tt{maximum = foldr1 max}
    \item \tt{minimum = foldr1 min}
    \item \tt{last = foldl1 (\textbackslash \_ r -> r)}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Сканиране на списъци (\tt{scanl}, \tt{scanr})}
  \tt{scanr} и \tt{scanl} връщат историята на пресмятането на \tt{foldr} и \tt{foldl}
  \pause\small
  \begin{itemize}[<+->]
  \item \tt{scanr :: (a -> b -> b) -> b -> [a] -> \alert{[b]}}
  \item \tt{scanr op nv [x$_1$, x$_2$, \ldots, x$_n$]} = \\
    \tt{[x$_1$ `op` (x$_2$ `op` \ldots (x$_n$ `op` nv) \ldots),}\\
    \tt{ x$_2$ `op` (\ldots (x$_n$ `op` nv) \ldots),}\\
    \ldots\\
    \tt{ x$_n$ `op` nv,}\\
    \tt{ nv]}
  \item \tt{scanl :: (b -> a -> b) -> b -> [a] -> \alert{[b]}}
  \item \tt{scanl op nv [x$_1$, x$_2$, \ldots, x$_n$]} = \\
    \tt{[nv,}\\
    \tt{ nv `op` x$_1$,}\\
    \tt{ (nv `op` x$_1$) `op` x$_2$,}\\
    \ldots\\
    \tt{ (\ldots((nv `op` x$_1$) `op` x$_2$) \ldots ) `op` x$_n$]}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Съшиване на списъци (\tt{zip}, \tt{zipWith})}
  \begin{itemize}[<+->]
  \item \tt{zip :: [a] -> [b] -> [(a,b)]}
    \begin{itemize}
    \item \evalsto{zip [x$_1$,x$_2$,\ldots,x$_n$]
        [y$_1$,y$_2$,\ldots,y$_n$]}{[(x$_1$,y$_1$),(x$_2$,y$_2$),\ldots,(x$_n$,y$_n$)]}
    \item ако единият списък е по-къс, спира когато свърши той
  \end{itemize}
  \item \tt{unzip :: [(a,b)] -> ([a],[b])}
    \begin{itemize}
    \item разделя списък от двойки на два списъка с равна
      дължина
    \item \evalsto{unzip
        [(x$_1$,y$_1$),(x$_2$,y$_2$),\ldots,(x$_n$,y$_n$)]}{([x$_1$,x$_2$,\ldots,x$_n$], [y$_1$,y$_2$,\ldots,y$_n$])}
    \end{itemize}
  \item \tt{zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]}
    \begin{itemize}
    \item съшива два списъка с дадена бинарна операция
    \item \evalsto{zipWith op [x$_1$,x$_2$,\ldots,x$_n$]
        [y$_1$,y$_2$,\ldots,y$_n$]}{[x$_1$ `op` y$_1$,x$_2$ `op`
        y$_2$,\ldots,x$_n$ `op` y$_n$]}
    \end{itemize}
  \item Примери
    \begin{itemize}
    \item \evalsto{zip [1..3] [5..10]}{[(1,5),(2,6),(3,7)]}
    \item \evalsto{zipWith (*) [1..3] [5..10]}{[5,12,21]}
    \item \tt{zip = zipWith (,)}
    \item \tt{unzip = foldr (\textbackslash(x,y) (l1,l2) -> (x:l1,y:l2)) ([],[])}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Разбивания на списъци}
  \begin{itemize}[<+->]
  \item \tt{takeWhile :: (a -> Bool) -> [a] -> [a]}
      \begin{itemize}
      \item връща първите елементи на списъка, за които е вярно условието
      \item \tt{takeWhile p = foldr (\textbackslash x r -> if p x then x:r else []) []}
      \item \evalsto{takeWhile (<0) [-3..3]}{[-3,-2,-1]}
      \end{itemize}
  \item \tt{dropWhile :: (a -> Bool) -> [a] -> [a]}
      \begin{itemize}
      \item премахва първите елементи на списъка, за които е вярно условието
      \item \evalsto{dropWhile (<0) [-3..3]}{[0,1,2,3]}
      \end{itemize}
  \item \tt{span :: (a -> Bool) -> [a] -> ([a], [a])}
    \begin{itemize}
    \item \tt{span p l = (takeWhile p l, dropWhile p l)}
    \item \evalsto{span (<0) [-3..3]}{([-3,-2,-1],[0,1,2,3])}
    \end{itemize}
  \item \tt{break :: (a -> Bool) -> [a] -> ([a],[a])}
    \begin{itemize}
    \item \tt{break p l = (takeWhile q l, dropWhile q l)}\\
      \hspace{15ex}\tt{where q x = not (p x)}
    \item \evalsto{break (>0) [-3..3]}{([-3,-2,-1-0],[1,2,3])}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Логически квантори (\tt{any}, \tt{all})}
  \begin{itemize}[<+->]
  \item \tt{any :: (a -> Bool) -> [a] -> Bool}
    \begin{itemize}
    \item проверява дали предикатът е изпълнен за \textbf{някой елемент} от списъка
    \item \tt{any p l = or (map p l)}
    \item \tt{elem x = any (==x)}
    \end{itemize}
  \item \tt{all :: (a -> Bool) -> [a] -> Bool}
    \begin{itemize}
    \item проверява дали предикатът е изпълнен за \textbf{всички елементи} на списъка
    \item \tt{all p l = and (map p l)}
    \item \tt{sorted l = all (\textbackslash(x,y) -> x <= y) (zip l (tail l))}
    \end{itemize}
  \end{itemize}
\end{frame}

\end{document}
