\documentclass{beamer}
\usepackage{fprog}

\title{Синтаксис на функции}

\date{6 януари 2016 г.}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

%\includeonlyframes{current}

\section{Разглеждане на случаи}

\begin{frame}[fragile]
  \frametitle{Разглеждане на случаи}
  Можем да дефинниране на функции с разглеждане на случаи по параметрите.\\
  Условието на всеки случай се нарича \textbf{пазач}.
  \begin{itemize}
    \item{} <име> \{<параметър>\}\\
      \hspace{3ex} \{ \tta| <пазач> \tta= <израз> \}$^+$
      \pause
    \item{} <име> <параметър$_1$> <параметър$_2$> ... <параметър$_k$>\\
      \hspace{3ex} \tta| <пазач$_1$> \tta= <израз$_1$>\\
      \hspace{3ex} \ldots\\
      \hspace{3ex} \tta| <пазач$_n$> \tta= <израз$_n$>\\
      \pause
    \item ако <пазач$_1$> е \tt{True} връща <израз$_1$>, а ако е \tt{False}:
    \item \ldots
    \item ако <пазач$_n$> е \tt{True} връща <израз$_n$>, а ако е \tt{False}:
    \item \alert{грешка!}
      \pause
    \item За удобство \tt{Prelude} дефинира \tt{otherwise = True}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Разглеждане на случаи --- примери}
\begin{semiverbatim}
fact n
  | n == 0    = 1
  | n > 0     = n * fact (n - 1)
\onslide<6->{  | n < 0     = error "подадено отрицателно число"}
\end{semiverbatim}
\onslide<+->
\begin{itemize}[<+->]
\item \evalstoerrp{fact (-5)}
\item добра практика е да имаме изчерпателни случаи
\item можем да използваме стандартната функция \tt{error}
\end{itemize}
\onslide<+->
\onslide<+->
\begin{verbatim}
grade x
  | x >= 5.5    = "Отличен"
  | x >= 4.5    = "Много добър"
  | x >= 3.5    = "Добър"
  | x >= 3      = "Среден"
  | otherwise   = "Слаб"
\end{verbatim}
\end{frame}

\section{Локални дефиниции}

\begin{frame}
  \frametitle{Локални дефиниции с \tt{let}}
  \begin{itemize}
  \item \tta{let} \{ <дефиниция> \}$^+$\\
    \tta{in} <тяло>
    \pause
  \item \tta{let} <дефиниция$_1$>\\
    \hspace{4.5ex}<дефиниция$_2$>\\
    \hspace{4.5ex}\ldots\\
    \hspace{4.5ex}<дефиниция$_n$>\\
    \tta{in} <тяло>
    \pause
  \item{} <дефиниция$_i$> се въвеждат едновременно
  \item областта на действие на дефинициите е само в рамките на \tt{let} конструкцията
  \item може да са взаимно рекурсивни
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Примери за \tt{let}}
  \begin{itemize}[<+->]
  \item \evalsto{let x = 5 in x + 3}8
  \item \evalsto{%
      \begin{tabular}[t]{@{}l@{ }l@{}}
        let&f x = y + x\\
           &y = 7\\
         in&f 2 * y
      \end{tabular}}{63}
  \item \tt{%
    \begin{tabular}[t]{@{}l@{ }l@{ }l@{}}
      fact2 n = &let fact n = &if n == 0 then 1\\
                &             &else n * fact (n-1)\\
                &in (fact n)\^{}2&
    \end{tabular}}
  \item В интерактивен режим (GHCi) \tt{let} може да се използва без \tt{in} за въвеждане на нови дефиниции
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Локални дефиниции с \tt{where}}
  \begin{itemize}
  \item{} <дефиниция-на-функция>\\
        \hspace{5ex} \tta{where} \{ <дефиниция> \}$^+$
        \pause
  \item{} <дефиниция-на-функция>\\
        \hspace{5ex} \tta{where} <дефиниция$_1$>\\
        \hspace{11ex} <дефиниция$_2$>\\
        \hspace{11ex}\ldots\\
        \hspace{11ex} <дефиниция$_n$>\\
        \pause
  \item{} <дефиниция$_i$> се въвеждат едновременно
  \item областта на действие на дефинициите е само в рамките на дефиницията на <функция>
  \item може да са взаимно рекурсивни
  \end{itemize}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{Примери за \tt{where}}
\begin{verbatim}
sumLastDigits n = lastDigit n + lastDigit (stripDigit n)
 where lastDigit  = (`mod` 10)
       stripDigit = (`div` 10)
\end{verbatim}
\pause
\begin{verbatim}
quadratic a b c
 | a == 0     = "линейно уравнение"
 | d > 0      = "две реални решения"
 | d == 0     = "едно реално решение"
 | otherwise  = "няма реални решения"
 where d = b^2 - 4*a*c
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Пример за комбиниране на \tt{let} и \tt{where}}
\begin{verbatim}
area x1 y1 x2 y2 x3 y3 =
   let a = dist x1 y1 x2 y2
       b = dist x2 y2 x3 y3
       c = dist x3 y3 x1 y1
       p = (a + b + c) / 2
   in sqrt (p * (p - a) * (p - b) * (p - c))
   where dist u1 v1 u2 v2 = sqrt (du^2 + dv^2)
          where du = u2 - u1
                dv = v2 - v1
\end{verbatim}
\end{frame}

\begin{frame}
  \frametitle{Сравнение на \tt{let} и \tt{where}}
  \begin{itemize}[<+->]
  \item \tt{let} е израз, който може да участва във всеки израз
  \item \tt{where} може да се използва само в рамките на дефиниция
  \item \tt{where} дефинициите са видими при всички разгледани случаи с пазачи
  \item \tt{let} са удобни когато има само едно <тяло>
  \item стилистична разлика:
    \begin{itemize}
    \item с \tt{let} помощните дефиниции се дават първи
    \item с \tt{where} акцентът пада върху основната дефиниция
    \end{itemize}
  \end{itemize}
\end{frame}

\section{Двумерен синтаксис}

\begin{frame}[fragile]
  \frametitle{Подравняване на дефинициите}
  \begin{columns}[onlytextwidth]
    \begin{column}{0.35\textwidth}
\begin{verbatim}
let h = f + g
    b x = 2
in  b h
\end{verbatim}
    \end{column}
    \pause
    \begin{column}{0.3\textwidth}
      а защо не:
    \end{column}
    \begin{column}{0.35\textwidth}
\begin{verbatim}
let h = f + g b
    x = 2
in  b h
\end{verbatim}
    \end{column}
  \end{columns}
  \vspace{1em}
\onslide<+->
\begin{itemize}[<+->]
\item \alert{Подравняването в Haskell има значение!}
\item Обхватът на блок от дефиниции се определя от това как са подравнени.
\item Дефинициите \textbf{вдясно и надолу} от първата са в същия блок
\item Дефинициите \textbf{вляво} са във външния блок
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Двумерен синтаксис --- пример}
{\ttfamily
\begin{tabular}{|lllll|}
\hline
\multicolumn 5{|l|}{area x1 y1 x2 y2 x3 y3 =}\\[0.5em]
\cline{3-4}
   &let &\multicolumn 2{|l|}{a = dist x1 y1 x2 y2}&\\
      &&\multicolumn 2{|l|}{b = dist x2 y2 x3 y3}&\\
      &&\multicolumn 2{|l|}{c = dist x3 y3 x1 y1}&\\
      &&\multicolumn 2{|l|}{p = (a + b + c) / 2}&\\
\cline{3-4}&&&&\\
   &\multicolumn 4{l|}{in sqrt (p * (p - a) * (p - b) * (p - c))}\\[0.5em]
\cline{3-5}
   &where &\multicolumn 3{|l|}{dist u1 v1 u2 v2 = sqrt (du\^{}2 + dv\^{}2)}\\
\cline{4-4}
          &&\multicolumn 1{|l}{where} &\multicolumn 1{|l|}{du = u2 - u1}&\\
          &&\multicolumn 1{|l}{}&\multicolumn 1{|l|}{dv = v2 - v1}&\\
\cline{4-4}
&&\multicolumn 3{|l|}{}\\
\cline{3-5}&&&&\\
\hline
\end{tabular}}
\end{frame}

\begin{frame}
  \frametitle{Алтернативен синтаксис за блокове}
  \begin{itemize}[<+->]
  \item Всъщност подравняването е синтактична захар за блоко в Haskell
  \item \tta\{ \{ <дефиниция> \tta; \} \tta\}
  \item \tta\{ <дефиниция$_1$> \tta; \ldots <дефиниция$_n$> [\tta;] \tta\}
  \item Интуитивни правила:
    \begin{itemize}
    \item при първия символ на дефиниция --- запомни позицията и сложи \tta\{
    \item начало на дефиниция по-надясно или по-надолу --- сложи \tta;
    \item начало на дефиниция по-наляво --- сложи \tta\}
    \end{itemize}
  \item Пазачите не използват синтаксис за блокове, можем безопасно да ги пишем и на един ред:
  \item \tt{fact n | n == 0 = 1 | otherwise = n * fact (n-1)}
  \end{itemize}
\end{frame}

\section{Образци}

\begin{frame}[fragile]
  \frametitle{Поредица от равенства}
  Можем да дефинираме функция с поредица от равенства:
\begin{verbatim}
fact 0 = 1
fact n = n * fact (n-1)
\end{verbatim}
  \pause
  Можем да имаме произволен брой равенства...
\begin{verbatim}
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
\end{verbatim}
  \pause
  \ldots или варианти за различните параметри
\begin{verbatim}
gcd 0 0 = error "няма най-голям общ делител"
gcd x 0 = x
gcd 0 y = y
gcd x y
 | x > y     = gcd (x-y) y
 | otherwise = gcd x (y-x)
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Образци}
  \begin{itemize}[<+->]
  \item Как се разбира кое равенство да се използва?
  \item Видът на формалните параметри наричаме \alert{образец}
  \item Търси се на кой образец пасва фактическия параметър
  \item Избира се първия образец \alert{отгоре надолу}
  \item Видове образци:
    \begin{itemize}
    \item \textbf{литерали} --- пасват при точно съвпадение
    \item \textbf{променливи} --- пасват винаги
    \item \textbf{анонимен образец \tt\_} ---  пасва винаги без да свързва фактическата стойност с име
    \end{itemize}
  \item Пример:
\begin{verbatim}
(&&) False _ = False
(&&) _     b = b
\end{verbatim}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Повторение на променливи}
  \begin{itemize}[<+->]
  \item Можем ли да напишем
\begin{semiverbatim}
gcd 0 0 = error "няма най-голям общ делител"
gcd x 0 = x
gcd 0 y = y
\alert{gcd x x = x}
gcd x y
 | x > y     = gcd (x-y) y
 | otherwise = gcd x (y-x)
\end{semiverbatim}
  \item \alert{Не!}
  \item Всички променливи използвани в образците трябва да са уникални
  \item Няма унификация, както в Пролог
    \begin{itemize}
    \item Има езици за функционално и логическо програмиране, в които това е позволено (напр. Curry)
    \end{itemize}
\end{itemize}
\end{frame}

\end{document}
