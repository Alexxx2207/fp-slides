\documentclass{beamer}
\usepackage{fprog}

\title{Структури от данни в Scheme}
\subtitle{матрици, дървета, асоциативни списъци, графи}

\date{11 ноември 2015 г.}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section{Матрици}

\subsection{Представяне}

\begin{frame}[fragile]
  \frametitle{Представяне на матрици}
  Можем да представим матрица като списък от списък от елементи:

  \begin{columns}[t,onlytextwidth]
    \begin{column}{0.5\textwidth}
      \begin{equation*}
        \left(
          \begin{array}{ccc}
            1 & 2 & 3\\
            4 & 5 & 6
          \end{array}
        \right)
      \end{equation*}
    \end{column}
    \begin{column}{0.5\textwidth}

      \tt{((1 2 3) (4 5 6))}
    \end{column}
  \end{columns}
  \vspace{1em}
  Проверка за коректност:
  \pause
\begin{verbatim}
(define (all p? l) (foldr (lambda (x y) (and x y)) #t l))

(define (matrix? m)
  (and (list? m)
       (not (null? (car m)))
       (all list? m)
       (all (lambda (row) (= (length row)
                             (length (car m)))) m)))
\end{verbatim}
\end{frame}

\subsection{Операции}

\begin{frame}[fragile]
  \frametitle{Базови операции}

  Брой редове и стълбове
  \pause
  \onslide<+->
\begin{semiverbatim}
\alt<+->{(define get-rows length)}{(define (get-rows m) (length m))}
(define (get-columns m) (length (car m)))
\end{semiverbatim}
  \onslide<+->
  Намиране на първи ред и стълб
  \onslide<+->
\begin{semiverbatim}
\alt<+->{(define get-first-row car)}{(define (get-first-row m) (car m))}
(define (get-first-column m) (map car m))
\end{semiverbatim}
  \onslide<+->
  Изтриване на първи ред и стълб
  \onslide<+->
\begin{semiverbatim}
\alt<+->{(define del-first-row cdr)}{(define (del-first-row m) (cdr m))}
(define (del-first-column m) (map cdr m))
\end{semiverbatim}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Разширени операции}

  Намиране на ред и стълб по индекс
  \pause
\begin{verbatim}
(define (get-row i m) (list-ref m i))
(define (get-column i m)
  (map (lambda (row) (list-ref row i)) m))
\end{verbatim}
  \pause
  Транспониране
  \pause
  \onslide<+->
  \begin{overprint}
\begin{semiverbatim}
(define (transpose m)
  (accumulate \rvl{cons} \rvl{'()} \rvl0 \rvl{(- (get-columns m) 1)}
              \rvl{(lambda (i) (get-column i m))} \rvl{1+}))
\end{semiverbatim}
  \end{overprint}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Аритметични операции}

  Събиране на матрици
  \pause
\begin{verbatim}
(define (sum-vectors v1 v2) (map + v1 v2))
(define (sum-matrices m1 m2) (map sum-vectors m1 m2))
\end{verbatim}
  \pause
  \vspace{1em}
  Умножение на матрици ($c_{i,j} = \vec a_i\cdot \vec b^T_j = \sum_{k=0}^n A_{i,k}B_{k,j}$)
  \pause
\begin{verbatim}
(define (mult-vectors v1 v2) (apply + (map * v1 v2)))
(define (mult-matrices m1 m2)
  (let ((m2t (transpose m2)))
       (map (lambda (row)
              (map (lambda (column) (mult-vectors row column))
                   m2t))
            m1)))
\end{verbatim}
\end{frame}


\section{Абстракция със структури от данни}

\subsection{Нива на абстракция}

\begin{frame}[<+->]
  \frametitle{Абстракция със структури от данни}

  \begin{definition}[Абстракция]
    Принцип за разделянето (``абстрахирането'') на \emph{представянето} на дадена структура от данни (СД) от нейното \emph{използване}.
  \end{definition}
  \begin{itemize}
  \item основен принцип на обектно-ориентираното програмиране
  \item позволява използването на СД преди представянето ѝ да е уточнено
  \item предимства:
    \begin{itemize}
    \item програмите работят на по-високо концептуално ниво със СД
    \item позволява алтернативни имплементации на дадена СД, подходящи за различни видове задачи
    \item влиянието на промени по представянето е ограничено до операциите, които ``знаят'' за него
    \item подобрения при представянето автоматично се разпространяват до по-горните нива на абстракция
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[<+->]
  \frametitle{Пример: рационално число}

  \begin{itemize}
  \item Логическо описание: обикновена дроб
  \item Физическо представяне: точкова двойка от цели числа
  \item Базови операции:
    \begin{itemize}[<.->]
    \item конструиране на рационално число
    \item получаване на числител
    \item получаване на знаменател
    \end{itemize}
  \item Аритметични операции:
    \begin{itemize}[<.->]
    \item събиране, изваждане
    \item умножение, деление
    \item сравнение
    \end{itemize}
  \item Приложни програми
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Нива на абстракция}

  \renewcommand{\bua}{\bigg\uparrow}

  \begin{center}
    \begin{tabular}{|c|}
      \hline
      приложни програми\\
      \\
      \hline
      \multicolumn 1c\bua\\
      \hline
      аритметични операции\\
      (+, -, *, /, =, <, >, <=, >=)\\
      \hline
      \multicolumn 1c\bua\\
      \hline
      базови операции\\
      (конструктор, селектори за числител и знаменател)\\
      \hline
      \multicolumn 1c\bua\\
      \hline
      физическо представяне\\
      (точкова двойка от цели числа)\\
      \hline
    \end{tabular}
  \end{center}
\end{frame}

\subsection{Абстракция с точкови двойки}

\begin{frame}[fragile]
  \frametitle{Рационални числа}

  Физическо представяне\\[1em]
  \begin{center}
    \begin{tabular}{cc}
      \hline
      \pointcell\\
      \hline
      \bda&\bda\\
      \fbox{числител} &\fbox{знаменател}
    \end{tabular}\\[1em]
  \end{center}
  \pause
  Базови операции
  \begin{itemize}[<+->]
  \item \alt<+->{\tt{(define make-rat cons)}}{\tt{(define (make-rat n d) (cons n d))}}
  \item \alt<+->{\tt{(define get-numer car)}}{\tt{(define (get-numer r) (car r))}}
  \item \alt<+->{\tt{(define get-denom cdr)}}{\tt{(define (get-denom r) (cdr r))}}
  \end{itemize}
  \onslide<+->
  \vspace{1em}
  По-добре:
\begin{verbatim}
(define (make-rat n d)
   (if (= d 0) (cons n 1) (cons n d)))
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Аритметични операции}
  \small
  \begin{columns}[t,onlytextwidth]
    \begin{column}{0.33\textwidth}
      \vspace{2em}
      \begin{equation*}
        \frac{n_1}{d_1}\frac{n_2}{d_2} = \frac{n_1n_2}{d_1d_2}
      \end{equation*}
      \vspace{4em}
      \begin{uncoverenv}<2->
        \begin{equation*}
          \frac{n_1}{d_1} + \frac{n_2}{d_2} = \frac{n_1d_2 + n_2d_1}{d_1d_2}
        \end{equation*}
      \end{uncoverenv}
      \vspace{4em}
      \begin{uncoverenv}<3->
        \begin{equation*}
          \frac{n_1}{d_1} < \frac{n_2}{d_2} \leftrightarrow n_1d_2 < n_2d_1
        \end{equation*}
      \end{uncoverenv}
    \end{column}

    \begin{column}{0.67\textwidth}
\begin{verbatim}
(define (*rat p q)
  (make-rat (* (get-numer p) (get-numer q))
            (* (get-denom p) (get-denom q))))
\end{verbatim}
      \begin{uncoverenv}<2->
\begin{verbatim}
(define (+rat p q)
  (make-rat (+ (* (get-numer p)
                  (get-denom q))
               (* (get-denom p)
                  (get-numer q)))
            (* (get-denom p) (get-denom q))))
\end{verbatim}
      \end{uncoverenv}
      \begin{uncoverenv}<3->
\begin{verbatim}
(define (<rat p q)
  (< (* (get-numer p) (get-denom q))
     (* (get-numer q) (get-denom p))))
\end{verbatim}
      \end{uncoverenv}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Програми с рационални числа}

  \begin{equation*}
    \sum_{i=0}^n \frac{x^i}{i!}
  \end{equation*}

  \onslide<+->

  \begin{overprint}
\begin{semiverbatim}
(define (my-exp x n)
  (accumulate \rvl{+rat} \rvl{(make-rat 0 1)} 0 n
              \rvl{(lambda (i) (make-rat (pow x i) (fact i)))} 1+))
\end{semiverbatim}
  \end{overprint}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Нормализация}

  \textbf{Проблем:} Числителят и знаменателят стават много големи!\\[1em]
  \textbf{Проблем:} \evalsto{(<rat (make-rat 1 2) (make-rat 1 -2))}{\#t}\\[1em]
  \pause
  \textbf{Идея:} Да работим с \emph{нормализирани} дроби $\frac p q$, където $p \in \mathbb Z, q \in \mathbb N^+$ и $gcd(p,q) = 1$.
  \pause
\begin{verbatim}
(define (make-rat n d)
  (if (or (= d 0) (= n 0)) (cons 0 1)
    (let* ((g (gcd n d))
           (ng (quotient n g))
           (dg (quotient d g)))
       (if (> dg 0) (cons ng dg)
                    (cons (- ng) (- dg))))))
\end{verbatim}
  \pause
  \alert{Не е нужно да правим каквито и да е други промени!}
\end{frame}

\subsection{Абстракция със сигнатура}

\begin{frame}[fragile]
  \frametitle{Сигнатура}

  \textbf{Проблем:} Не можем да различим СД с еднакви представяния! (рационално число, комплексно число, точка в равнината)\\
  \pause
  \textbf{Идея:} Да добавим ``етикет'' на обекта
  \small
  \begin{center}
    \begin{tabular}{cc@{}c@{}cc}
      \cline{1-2}\cline{4-5}
      \pointcell&$\nextarrow$&\pointcell\\
      \cline{1-2}\cline{4-5}
      \bda&&&\bda&\bda\\
      \fbox{\tt{rat}}&&&\fbox{числител}&\fbox{знаменател}
    \end{tabular}
  \end{center}
  \pause
\begin{semiverbatim}
(define (make-rat n d)
  \alert{(cons 'rat}
    (if (or (= d 0) (= n 0)) (cons 0 1)
      (let* ((g (gcd n d))
             (ng (quotient n g))
             (dg (quotient d g)))
         (if (> dg 0) (cons ng dg)
                      (cons (- ng) (- dg)))))))
(define get-numer \alert{cadr})
(define get-denom \alert{cddr})
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Проверка за коректност}

  Вече можем да проверим дали даден обект е рационално число:
\begin{verbatim}
(define (rat? p)
  (and (pair? p) (eq? (car p) 'rat)
       (pair? (cdr p)) (number? (cadr p)) (number? (cddr p))))
\end{verbatim}

  \pause

  Можем да добавим проверка за коретност:
\begin{verbatim}
(define (check-rat f)
  (lambda (p)
    (if (rat? p) (f p) 'error)))

(define get-numer (check-rat cadr))
(define get-denom (check-rat cddr))
\end{verbatim}
\end{frame}

\subsection{Капсулация}

\begin{frame}[fragile]
  \frametitle{Капсулация на базови операции}
  \textbf{Проблем:} операциите над СД са видими глобално\\[1em]
  \pause
  \textbf{Идея:} да ги направим ``private''
  \pause
\begin{semiverbatim}
(define (make-rat n d)
  (lambda (prop)
    (case prop
      ('get-numer n)
      ('get-denom d)
      ('print (cons n d)))))
\end{semiverbatim}
  \pause
  \begin{itemize}
  \item \tt{(define r (make-rat 3 5))}
  \item \evalsto{(r 'get-numer)}3
  \item \evalsto{(r 'get-denom)}5
  \item \evalsto{(r 'print)}{(3 . 5)}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Нормализация при капсулация}
\begin{semiverbatim}
(define (make-rat n d)
  \alert{(let* ((g (gcd n d))
         (numer (quotient n g))
         (denom (quotient d g)))}
   (lambda (prop)
    (case prop
      ('get-numer numer)
      ('get-denom denom)
      ('print (cons numer denom))))))
\end{semiverbatim}
  \pause
  \begin{itemize}
  \item \tt{(define r (make-rat 4 6))}
  \item \evalsto{(r 'print)}{(2 . 3)}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Капсулация на операции с аргументи}
\small
\begin{semiverbatim}
(define (make-rat n d)
  (let* ((g (gcd n d))
         (numer (quotient n g))
         (denom (quotient d g)))
   (lambda (prop . params)
     (case prop
       ('get-numer numer)
       ('get-denom denom)
       ('print (cons numer denom))
       \alert{('* (let ((r (car params)))
            (make-rat (* numer (r 'get-numer))
                      (* denom (r 'get-denom)))))}))))
\end{semiverbatim}
  \pause
  \begin{itemize}
  \item \tt{(define r1 (make-rat 3 5))}
  \item \tt{(define r2 (make-rat 5 2))}
  \item \evalsto{((r1 '* r2) 'print)}{(3 . 2)}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Извикване на собствени операции}
\small
\begin{semiverbatim}
(define (make-rat n d)
  (let* ((g (gcd n d))
         (numer (quotient n g))
         (denom (quotient d g)))
   \alert{(define (self prop . params)}
     (case prop
       ('get-numer numer)
       ('get-denom denom)
       ('print (cons numer denom))
       ('* (let ((r (car params)))
            (make-rat (* \alert{(self 'get-numer)} (r 'get-numer))
                      (* \alert{(self 'get-denom)} (r 'get-denom)))))))
   \alert{self}))
\end{semiverbatim}
\end{frame}

\section{Двоични дървета}

\subsection{Представяне}

\begin{frame}[fragile]
  \frametitle{Представяне на двоични дървета}
  Представяме двоични дървета като вложени списъци от три елемента:\\[1em]
  \begin{columns}[t,onlytextwidth]
    \begin{column}{0.5\textwidth}
      \centering
      \begin{forest} baseline
        [корен [ляво] [дясно]]
      \end{forest}
    \end{column}
    \begin{column}{0.5\textwidth}
      \tt(<корен> <ляво> <дясно>\tt)
    \end{column}
  \end{columns}
  \pause
  \vspace{1em}
  Пример:
  \begin{columns}[t,onlytextwidth]
    \begin{column}{0.5\textwidth}
      \centering
      \begin{forest} baseline, for tree={circle,draw}
        [1 [2] [3 [4] [5]]]
      \end{forest}
    \end{column}
    \begin{column}{0.5\textwidth}
\begin{verbatim}
(1 (2 () ())
   (3 (4 () ())
      (5 () ())))
\end{verbatim}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Операции}

\begin{frame}[fragile]
  \frametitle{Базови операции}

  Проверка за коректност:
  \pause
\begin{verbatim}
(define (tree? t)
  (or (null? t)
      (and (list t) (= (length t) 3))
           (tree? (cadr t))
           (tree? (caddr t))))
\end{verbatim}
  \pause
  Конструктори:
  \pause
\begin{verbatim}
(define empty-tree '())
(define (make-tree root left right) (list root left right))
\end{verbatim}
  \pause
  Селектори:
  \pause
\begin{verbatim}
(define root-tree car)
(define left-tree cadr)
(define right-tree caddr)
(define empty-tree? null?)
\end{verbatim}
\end{frame}

\begin{frame}[fragile,fragile,fragile]
  \frametitle{Разширени операции}

  Дълбочина на дърво:
  \pause
\begin{verbatim}
(define (depth-tree t)
  (if (empty-tree? t) 0
      (1+ (max (depth (left-tree t))
               (depth (right-tree t))))))
\end{verbatim}
  \pause
  Намиране на поддърво:
  \pause
\begin{verbatim}
(define (member-tree x t)
  (cond ((empty-tree? t) #f)
        ((eq? x (root-tree t)) t)
        (else (or (member-tree x (left-tree t))
                  (member-tree x (right-tree t))))))
\end{verbatim}
\end{frame}
\end{document}

\begin{frame}[fragile]
  \frametitle{Търсене на път в двоично дърво}

  \textbf{Задача:} Да се намери в дървото път от корена до даден възел \tt x.
  \pause
\begin{verbatim}
(define (path-tree x t)
  (cond ((empty-tree? t) #f)
        ((eq? x (root-tree t)) (list x))
        (else (cons#f (root-tree t)
                      (or (path-tree x (left-tree t))
                          (path-tree x (right-tree t)))))))

(define (cons#f h t) (and t (cons h t)))
\end{verbatim}
\end{frame}

\section{Асоциативни списъци}

\subsection{Дефиниция}

\begin{frame}
  \frametitle{Асоциативни списъци}
  \begin{definition}
    Асоциативните списъци (още: речник, хеш, map) са списъци от точкови двойки \tt(<ключ> \tt. <стойност>\tt). <ключ> и <стойност> може да са произволни S-изрази.
  \end{definition}
  \vspace{1em}
  \tt{((}$K_1$ \tt. $V_1$\tt) \tt($K_1$ \tt. $V_2$\tt) \ldots \tt($K_n$ \tt. $V_n$\tt{))}\\[1em]
  \begin{tabular}{*2{cc@{}c@{}}@{\hskip 1ex}cc@{}cc}
    \cline{1-2}\cline{4-5}\cline{9-10}
    \nextcell&\nextcell&\ldots&$\nextarrow$&\nilcell\\
    \cline{1-2}\cline{4-5}\cline{9-10}
    \bda&&&\bda&&&&&\bda\\
    \cline{1-2}\cline{4-5}\cline{9-10}
    \pointcell&&\pointcell&&&&\pointcell\\
    \cline{1-2}\cline{4-5}\cline{9-10}
    \bda&\bda&&\bda&\bda&&&&\bda&\bda\\
    \fbox{$K_1$}&\fbox{$V_1$}&&\fbox{$K_2$}&\fbox{$V_2$}&&&&\fbox{$K_n$}&\fbox{$V_n$}
  \end{tabular}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Примери за асоциативни списъци}

  \begin{itemize}[<+->]
  \item \tt{((1 . 2) (2 . 3) (3 . 4))}
  \item \tt{((a . 10) (b . 12) (c . 18))}
  \item \tt{((l1 1 8) (l2 10 1 2) (l3))}
  \item \tt{((al1 (1 . 2) (2 . 3)) (al2 (b)) (al3 (a . b) (c . d)))}
  \end{itemize}
  \vspace{1em}
  \onslide<+->
  Създаване на асоциатвен списък по списък от ключове и функция:
\begin{verbatim}
(define (make-alist f keys)
  (map (lambda (x) (cons x (f x))) l))
\end{verbatim}
  \onslide<+->
  Пример:\\
  \evalsto{(make-alist square '(1 3 5))}{((1 . 1) (3 . 9) (5 . 25))}
\end{frame}

\subsection{Операции}

\begin{frame}[fragile]
  \frametitle{Операции над асоциативни списъци}

  \begin{itemize}[<+->]
  \item \tt{(define (keys alist) (map car alist))}
  \item \tt{(define (values alist) (map cdr alist))}
  \item \tta{(assoc }<ключ> <асоциативен-списък>\tta)
    \begin{itemize}[<.->]
    \item Ако <ключ> се среща сред ключовете на <асоциативен-списък>,
      връща първата двойка \tt(<ключ> \tt. <стойност>\tt)
    \item Ако <ключ> не се среща сред ключовете, връща \tt{\#f}
    \item Сравнението се извършва с \tt{equal?}
    \end{itemize}
  \item \tta{(assqv }<ключ> <асоциативен-списък>\tta)
    \begin{itemize}[<.->]
    \item също като \tt{assoc}, но сравнява с \tt{eqv?}
    \end{itemize}
  \item \tta{(assq }<ключ> <асоциативен-списък>\tta)
    \begin{itemize}[<.->]
    \item също като \tt{assoc}, но сравнява с \tt{eq?}
    \end{itemize}
  \item Изтриване на ключ и съответната му стойност:\\
    \onslide<+->
\begin{verbatim}
(define (del-key-value key alist)
  (filter (lambda (kv) (not (eq? (car kv) key))) alist))
\end{verbatim}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,fragile,fragile]
  \frametitle{Задаване на стойност за ключ}
\small
  \textbf{Вариант №1 (грозен и бърз):}
\begin{verbatim}
(define (add-key-value key value alist)
   (let ((new-kv (cons key value)))
        (cond ((null? alist) (list new-kv))
              ((eq? (caar alist) key)
               (cons new-kv (cdr alist)))
              (else (cons (car alist)
                    (add-key-value key value (cdr alist))))))
\end{verbatim}
  \pause
  \textbf{Вариант №2 (красив и бавен):}
\begin{verbatim}
(define (add-key-value key value alist)
  (let ((new-kv (cons key value)))
       (if (assq key alist)
           (map (lambda (kv) (if (eq? (car kv) key)
                                 new-kv kv)) alist)
           (cons new-kv alist))))
\end{verbatim}
\end{frame}

\section{Графи}

\subsection{Представяне}

\subsection{Операции}

\subsection{Търсене в дълбочина}

\subsection{Търсене в ширина}

\end{document}
