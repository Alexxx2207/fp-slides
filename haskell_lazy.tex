\documentclass{beamer}
\usepackage{fprog}

\title[Лениво оценяване]{Лениво оценяване и програмиране от по-висок ред}

\date{7 януари 2016 г.}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section{Лениво оценяване}

\begin{frame}
  \frametitle{Щипка $\lambda$-смятане}
  \newcommand{\lra}{\rightarrow}
  \begin{itemize}[<+->]
  \item $\lambda$-изрази: $E ::= x \;|\; E_1(E_2) \;|\; \lambda x\, E$
  \item Изчислително правило: $(\lambda x\,E_1)(E_2) \mapsto E_1[x := E_2]$
  \item В какъв ред прилагаме изчислителното правило?
  \item Нека $f := \lambda x\; x!$, $g := \lambda z\;z^2+z$
  \item $g(f(4)) \lra \quad ?$
  \item $g(\underline{f(4)})
    \onslide<+->
    \lra g(\underline{4!})
    \onslide<+->
    \lra \underline{g(24)}
    \onslide<+->
    \lra 24^2 + 24
    \onslide<+->
    \lra 600$
    \begin{itemize}
    \item<16-> оценяваме \alert{отвътре навън}
    \item<17-> \alert{стриктно} (апликативно, лакомо) оценяване
    \end{itemize}
  \item $\underline{g(f(4))}
    \onslide<+->
    \lra \underline{(f(4))}^2 + \underline{f(4)}
    \onslide<+->
    \lra (\underline{4!})^2 + \underline{4!}
    \onslide<+->
    \lra 24^2 + 24
    \onslide<+->
    \lra 600$
    \begin{itemize}
    \item<16-> оценяваме \alert{отвън навътре}
    \item<17-> \alert{нестриктно} (нормално, лениво) оценяване
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Стриктно и нестриктно оценяване}
  Стриктното оценяване
  \begin{itemize}[<+->]
  \item се използва в повечето езици за програмиране
  \item се нарича още ``call-by-value'' (извикване по стойност)
  \item позволява лесно да се контролира реда на изпълнение
  \item пестеливо откъм памет, понеже ``пази чисто''
  \end{itemize}
  \onslide<+->
  Нестриктното оценяване
  \begin{itemize}[<+->]
  \item е по-рядко използвано
  \item въпреки това се среща в някаква форма в повечето езици!
    \begin{itemize}
    \item \tt{x = p != NULL ? p->data : 0;}
    \item \tt{found = i < n \&\& a[i] == x}
    \end{itemize}
  \item нарича се още ``call-by-name'' (извикване по име)
  \item може да спести сметки, понеже ``изхвърля боклуците''
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Кога мързелът помага}
  \newcommand{\lra}{$\;\rightarrow\;$}
\begin{verbatim}
(define (f x y) (if (< x 5) x y)
(define (g l)   (f (car l) (cadr l)))
\end{verbatim}
\pause
\begin{tabular}[t]{l@{}l}
\tt{\underline{(g '(3))}}
\pause
&\lra \tt{(f \underline{(car '(3))} (cadr '(3)))}\\
\pause
&\lra \tt{(f 3 \underline{(cadr '(3))})}
\pause
\lra \alert{Грешка!}
\end{tabular}
\pause
\begin{verbatim}
f x y = if x < 5 then x else y
g l   = f (head l) (head (tail l))
\end{verbatim}
\pause
\begin{tabular}[t]{l@{}l}
\tt{\underline{g [3]}}
\pause
&\lra \tt{\underline{f (head [3]) (head (tail [3]))}}\\
\pause
&\lra \tt{if \underline{head [3]} < 5 then head [3] else head (tail [3])}\\
\pause
&\lra \tt{if \underline{3 < 5} then head [3] else head (tail [3])}\\
\pause
&\lra \tt{\underline{if True then head [3] else head (tail [3])}}\\
\pause
&\lra \tt{\underline{head [3]}}
\pause
\lra \tt 3
\end{tabular}
\end{frame}

\begin{frame}
  \frametitle{Теорема за нормализация}
  \begin{itemize}[<+->]
  \item всеки път когато апликативното оценяване дава резултат и нормалното оценяване дава резултат
  \item има случаи, когато нормалното оценяване дава резултат, но апликативното не!
  \item нещо повече:
  \end{itemize}
  \onslide<.->
  \begin{theorem}[за нормализация, Church-Rosser]
    Ако има някакъв ред на оценяване на програмата, който достига до резултат, то и с нормална стратегия на оценяване ще достигнем до някакъв резултат.
  \end{theorem}
  \onslide<+->
  \begin{corollary}
    Ако с нормално оценяване програмата даде грешка или не завърши, то няма да получим резултат с \alert{никоя друга стратегия на оценяване}.
  \end{corollary}
\end{frame}

\begin{frame}
  \frametitle{Извикване при нужда (``call-by-need'')}

Ако $g(z) = z^2 + z$, $g(g(g(2))) = ?$
\pause
\begin{equation*}
  \begin{array}{rl}
  g(g(g(2))) \pause &\mapsto g(g(2))^2 + g(g(2)) \pause\mapsto (g(2)^2+ g(2))^2 + g(2)^2 + g(2) \pause\mapsto\\
  &\mapsto ((2^2+2)^2+2^2+2)+(2^2+2)^2 + 2^2+2 \mapsto \ldots
  \end{array}
\end{equation*}\pause
Времето и паметта нарастват експоненциално!\\
\pause
\fbox{\textbf{Идея:} $(\lambda x\,E_1)(E_2) \mapsto E_1\where x = E_2$}
\pause
\begin{equation*}
  \begin{array}{rl}
    g(g(g(2))) \pause &\mapsto x^2 + x \where x = g(g(2)) \pause \mapsto\\
    &\mapsto x^2 + x \where x = y^2 + y \where y = g(2) \pause \mapsto\\
    &\mapsto x^2 + x \where x = y^2 + y \where y = z^2 + 2 \where z = 2 \pause \mapsto\\
    &\mapsto x^2 + x \where x = y^2 + y \where y = 6 \pause \mapsto\\
    &\mapsto x^2 + x \where x = 42 \mapsto 1806
  \end{array}
\end{equation*}\pause\vspace{-1.5em}
\begin{itemize}[<+->]
\item Избягва се повторението чрез споделяне на общи подизрази
\item Заместването се извършва чак когато е \alert{абсолютно наложително}
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Кога се налага оценяване на израз?}
  Във всеки даден момент Haskell оценява някой израз \tt s. \pause
  \begin{itemize}[<+->]
  \item ако \tt{s = if e then e$_1$ else e$_2$}
    \begin{itemize}
    \item първо се оценява \tt e
    \item ако оценката е \tt{True}, се преминава към оценката на e$_1$
    \item ако оценката е \tt{False}, се преминава към оценката на e$_2$
    \end{itemize}
  \item ако \tt{s = f e$_1$ e$_2$ \ldots\ e$_n$}, за \tt f $n$-местна примитивна функция:
    \begin{itemize}
    \item оценяваме последователно \tt{e$_1$}, \ldots\ \tt{e$_n$}
    \item прилагаме примитивната операция над оценките им
    \end{itemize}
  \item нека сега да допуснем, че \tt{s = f e}
  \item първо се оценява \tt f, за да разберем как да продължим
  \item ако \tt{f x$_1$ \ldots\ x$_n$ | g$_1$ = t$_1$ \ldots\ | g$_k$ = t$_k$} е дефинирана чрез пазачи:
    \begin{itemize}
    \item тогава заместваме \tt f със израза: \tt{\textbackslash x$_1$ \ldots\ x$_n$ -> if g$_1$ then t$_1$ else \ldots\ if g$_k$ then t$_k$ else error "..."}

    \end{itemize}
  \item ако \tt f е конструктор (константа), \alert{оценката остава \tt{f e}}
  \item ако \tt{f = \textbackslash p -> t}, където \tt p е образец, редът на оценяване зависи от образеца!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Кога се оценяват изразите при използване на образци?}
  Как се оценява \tt{(\textbackslash p -> t) e}?\pause
  \begin{itemize}[<+->]
  \item ако \tt{p = c} е константа:
    \begin{itemize}
    \item преминава се към оценката на аргумента \tt e
    \item ако се установи че оценката тя съвпада с \tt c, преминава се към оценката на тялото \tt t
    \end{itemize}
  \item ако \tt{p = \_} е анонимният образец:
    \begin{itemize}
    \item преминава се директно към оценката на \tt t \alert{без да се оценява \tt e}
    \end{itemize}
  \item ако \tt{p = x} е променлива:
    \begin{itemize}
    \item преминава се към оценка на израза \tt t \alert{като се въвежда локалната дефиниция \tt{x = e}}
    \end{itemize}
  \item ако \tt{p = (p$_1$,p$_2$,\ldots,p$_n$)}:
    \begin{itemize}
    \item преминава се към оценката на \tt e
    \item ако се установи, че тя е от вида \tt{(e$_1$,e$_2$,\ldots,e$_n$)}, преминава се към оценката на израза \tt{(\textbackslash p$_1$ p$_2$ \ldots\ p$_n$ -> t) e$_1$ e$_2$ \ldots\ e$_n$}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Кога се оценяват изразите при използване на образци?}
  Как се оценява \tt{(\textbackslash p -> t) e}?
  \begin{itemize}[<+->]
  \item ако \tt{p = (p$_h$:p$_t$)}:
    \begin{itemize}
    \item преминава се към оценката на \tt e
    \item ако се установи, че тя е от вида \tt{(e$_h$:e$_t$)}, преминава се към оценката на израза \tt{(\textbackslash p$_h$ p$_t$ -> t) e$_h$ e$_t$}
    \end{itemize}
  \item ако \tt{p = [p$_1$,p$_2$,\ldots,p$_n$]}:
    \begin{itemize}
    \item преминава се към оценката на \tt e
    \item ако се установи, че тя е от вида \tt{[e$_1$,e$_2$,\ldots,e$_n$]}, преминава се към оценката на израза \tt{(\textbackslash p$_1$ p$_2$ \ldots\ p$_n$ -> t) e$_1$ e$_2$ \ldots\ e$_n$}
    \item всъщност е еквивалентно да разгледаме \tt p като \tt{p$_1$:p$_2$:\ldots:p$_n$:[]}
    \end{itemize}
  \item ако има няколко равенства за \tt f с използване на различни образци, се търси кой образец пасва отгоре надолу
  \end{itemize}
\end{frame}

\end{document}
