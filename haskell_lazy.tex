\documentclass{beamer}
\usepackage{fprog}

\title[Лениво оценяване]{Лениво оценяване и програмиране от по-висок ред}

\date{7 януари 2016 г.}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section{Лениво оценяване}

\begin{frame}
  \frametitle{Щипка $\lambda$-смятане}
  \newcommand{\lra}{\rightarrow}
  \begin{itemize}[<+->]
  \item $\lambda$-изрази: $E ::= x \;|\; E_1(E_2) \;|\; \lambda x\, E$
  \item Изчислително правило: $(\lambda x\,E_1)(E_2) \mapsto E_1[x := E_2]$
  \item В какъв ред прилагаме изчислителното правило?
  \item Нека $f := \lambda x\; x!$, $g := \lambda z\;z^2+z$
  \item $g(f(4)) \lra \quad ?$
  \item $g(\underline{f(4)})
    \onslide<+->
    \lra g(\underline{4!})
    \onslide<+->
    \lra \underline{g(24)}
    \onslide<+->
    \lra 24^2 + 24
    \onslide<+->
    \lra 600$
    \begin{itemize}
    \item<16-> оценяваме \alert{отвътре навън}
    \item<17-> \alert{стриктно} (апликативно, лакомо) оценяване
    \end{itemize}
  \item $\underline{g(f(4))}
    \onslide<+->
    \lra \underline{(f(4))}^2 + \underline{f(4)}
    \onslide<+->
    \lra (\underline{4!})^2 + \underline{4!}
    \onslide<+->
    \lra 24^2 + 24
    \onslide<+->
    \lra 600$
    \begin{itemize}
    \item<16-> оценяваме \alert{отвън навътре}
    \item<17-> \alert{нестриктно} (нормално, лениво) оценяване
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Стриктно и нестриктно оценяване}
  Стриктното оценяване
  \begin{itemize}[<+->]
  \item се използва в повечето езици за програмиране
  \item се нарича още ``call-by-value'' (извикване по стойност)
  \item позволява лесно да се контролира реда на изпълнение
  \item пестеливо откъм памет, понеже ``пази чисто''
  \end{itemize}
  \onslide<+->
  Нестриктното оценяване
  \begin{itemize}[<+->]
  \item е по-рядко използвано
  \item въпреки това се среща в някаква форма в повечето езици!
    \begin{itemize}
    \item \tt{x = p != NULL ? p->data : 0;}
    \item \tt{found = i < n \&\& a[i] == x}
    \end{itemize}
  \item нарича се още ``call-by-name'' (извикване по име)
  \item може да спести сметки, понеже ``изхвърля боклуците''
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Кога мързелът помага}
  \newcommand{\lra}{$\;\rightarrow\;$}
\begin{verbatim}
(define (f x y) (if (< x 5) x y)
(define (g l)   (f (car l) (cadr l)))
\end{verbatim}
\pause
\begin{tabular}[t]{l@{}l}
\tt{\underline{(g '(3))}}
\pause
&\lra \tt{(f \underline{(car '(3))} (cadr '(3)))}\\
\pause
&\lra \tt{(f 3 \underline{(cadr '(3))})}
\pause
\lra \alert{Грешка!}
\end{tabular}
\pause
\begin{verbatim}
f x y = if x < 5 then x else y
g l   = f (head l) (head (tail l))
\end{verbatim}
\pause
\begin{tabular}[t]{l@{}l}
\tt{\underline{g [3]}}
\pause
&\lra \tt{\underline{f (head [3]) (head (tail [3]))}}\\
\pause
&\lra \tt{if \underline{head [3]} < 5 then head [3] else head (tail [3])}\\
\pause
&\lra \tt{if \underline{3 < 5} then head [3] else head (tail [3])}\\
\pause
&\lra \tt{\underline{if True then head [3] else head (tail [3])}}\\
\pause
&\lra \tt{\underline{head [3]}}
\pause
\lra \tt 3
\end{tabular}
\end{frame}

\begin{frame}
  \frametitle{Теорема за нормализация}
  \begin{itemize}[<+->]
  \item всеки път когато апликативното оценяване дава резултат и нормалното оценяване дава резултат
  \item има случаи, когато нормалното оценяване дава резултат, но апликативното не!
  \item нещо повече:
  \end{itemize}
  \onslide<.->
  \begin{theorem}[за нормализация, Church-Rosser]
    Ако има някакъв ред на оценяване на програмата, който достига до резултат, то и с нормална стратегия на оценяване ще достигнем до някакъв резултат.
  \end{theorem}
  \onslide<+->
  \begin{corollary}
    Ако с нормално оценяване програмата даде грешка или не завърши, то няма да получим резултат с \alert{никоя друга стратегия на оценяване}.
  \end{corollary}
\end{frame}

\end{document}
