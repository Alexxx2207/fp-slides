\documentclass{beamer}
\usepackage{fprog}

\title[Лениво оценяване]{Лениво оценяване и програмиране от по-висок ред}

\date{7 януари 2016 г.}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

%\includeonlyframes{current}

\section{Лениво оценяване}

\begin{frame}
  \frametitle{Щипка $\lambda$-смятане}
  \newcommand{\lra}{\rightarrow}
  \begin{itemize}[<+->]
  \item $\lambda$-изрази: $E ::= x \;|\; E_1(E_2) \;|\; \lambda x\, E$
  \item Изчислително правило: $(\lambda x\,E_1)(E_2) \mapsto E_1[x := E_2]$
  \item В какъв ред прилагаме изчислителното правило?
  \item Нека $f := \lambda x\; x!$, $g := \lambda z\;z^2+z$
  \item $g(f(4)) \lra \quad ?$
  \item $g(\underline{f(4)})
    \onslide<+->
    \lra g(\underline{4!})
    \onslide<+->
    \lra \underline{g(24)}
    \onslide<+->
    \lra 24^2 + 24
    \onslide<+->
    \lra 600$
    \begin{itemize}
    \item<16-> оценява се \alert{отвътре навън}
    \item<17-> \alert{стриктно} (апликативно, лакомо) оценяване
    \end{itemize}
  \item $\underline{g(f(4))}
    \onslide<+->
    \lra \underline{(f(4))}^2 + \underline{f(4)}
    \onslide<+->
    \lra (\underline{4!})^2 + \underline{4!}
    \onslide<+->
    \lra 24^2 + 24
    \onslide<+->
    \lra 600$
    \begin{itemize}
    \item<16-> оценява се \alert{отвън навътре}
    \item<17-> \alert{нестриктно} (нормално, лениво) оценяване
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Стриктно и нестриктно оценяване}
  Стриктното оценяване
  \begin{itemize}[<+->]
  \item се използва в повечето езици за програмиране
  \item се нарича още ``call-by-value'' (извикване по стойност)
  \item позволява лесно да се контролира реда на изпълнение
  \item пестеливо откъм памет, понеже ``пази чисто''
  \end{itemize}
  \onslide<+->
  Нестриктното оценяване
  \begin{itemize}[<+->]
  \item е по-рядко използвано
  \item въпреки това се среща в някаква форма в повечето езици!
    \begin{itemize}
    \item \tt{x = p != NULL ? p->data : 0;}
    \item \tt{found = i < n \&\& a[i] == x}
    \end{itemize}
  \item нарича се още ``call-by-name'' (извикване по име)
  \item може да спести сметки, понеже ``изхвърля боклуците''
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Кога мързелът помага}
  \newcommand{\lra}{$\;\rightarrow\;$}
\begin{verbatim}
(define (f x y) (if (< x 5) x y))
(define (g l)   (f (car l) (cadr l)))
\end{verbatim}
\pause
\begin{tabular}[t]{l@{}l}
\tt{\underline{(g '(3))}}
\pause
&\lra \tt{(f \underline{(car '(3))} (cadr '(3)))}\\
\pause
&\lra \tt{(f 3 \underline{(cadr '(3))})}
\pause
\lra \alert{Грешка!}
\end{tabular}
\pause
\begin{verbatim}
f x y = if x < 5 then x else y
g l   = f (head l) (head (tail l))
\end{verbatim}
\pause
\begin{tabular}[t]{l@{}l}
\tt{\underline{g [3]}}
\pause
&\lra \tt{\underline{f (head [3]) (head (tail [3]))}}\\
\pause
&\lra \tt{if \underline{head [3]} < 5 then head [3] else head (tail [3])}\\
\pause
&\lra \tt{if \underline{3 < 5} then head [3] else head (tail [3])}\\
\pause
&\lra \tt{\underline{if True then head [3] else head (tail [3])}}\\
\pause
&\lra \tt{\underline{head [3]}}
\pause
\lra \tt 3
\end{tabular}
\end{frame}

\begin{frame}
  \frametitle{Теорема за нормализация}
  \begin{itemize}[<+->]
  \item всеки път когато апликативното оценяване дава резултат и нормалното оценяване дава резултат
  \item има случаи, когато нормалното оценяване дава резултат, но апликативното не!
  \item нещо повече:
  \end{itemize}
  \onslide<.->
  \begin{theorem}[за нормализация, Church-Rosser]
    Ако има някакъв ред на оценяване на програмата, който достига до резултат, то и с нормална стратегия на оценяване ще достигнем до някакъв резултат.
  \end{theorem}
  \onslide<+->
  \begin{corollary}
    Ако с нормално оценяване програмата даде грешка или не завърши, то няма да получим резултат с \alert{никоя друга стратегия на оценяване}.
  \end{corollary}
\end{frame}

\begin{frame}
  \frametitle{Извикване при нужда (``call-by-need'')}

Ако $g(z) = z^2 + z$, $g(g(g(2))) = ?$
\pause
\begin{equation*}
  \begin{array}{rl}
  g(g(g(2))) \pause &\mapsto g(g(2))^2 + g(g(2)) \pause\mapsto (g(2)^2+ g(2))^2 + g(2)^2 + g(2) \pause\mapsto\\
  &\mapsto ((2^2+2)^2+2^2+2)+(2^2+2)^2 + 2^2+2 \mapsto \ldots
  \end{array}
\end{equation*}\pause
Времето и паметта нарастват експоненциално!\\
\pause
\fbox{\textbf{Идея:} $(\lambda x\,E_1)(E_2) \mapsto \lett{x = E_2}{E_1}$}
\pause
\begin{equation*}
  \begin{array}{rl}
    g(g(g(2))) \pause &\mapsto \lett{x = g(g(2))}{x^2 + x}\pause \mapsto\\
    &\mapsto \lett{y=g(2)}{\lett{x=y^2+y}{x^2 + x}} \pause \mapsto\\
    &\mapsto \lett{z=2}{\lett{y=z^2+z}{\lett{x=y^2+y}{x^2 + x}}} \pause \mapsto\\
    &\mapsto \lett{y=6}{\lett{x = y^2+y}{x^2 + x}} \pause \mapsto\\
    &\mapsto \lett{x=42}{x^2 + x} \mapsto 1806
  \end{array}
\end{equation*}\pause\vspace{-1.5em}
\begin{itemize}[<+->]
\item Избягва се повторението чрез споделяне на общи подизрази
\item Заместването се извършва чак когато е \alert{абсолютно наложително}
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Кога се налага оценяване на израз?}
  Във всеки даден момент Haskell оценява някой израз \tt s. \pause
  \begin{itemize}[<+->]
  \item ако \tt{s = if e then e$_1$ else e$_2$}
    \begin{itemize}
    \item първо се оценява \tt e
    \item ако оценката е \tt{True}, се преминава към оценката на e$_1$
    \item ако оценката е \tt{False}, се преминава към оценката на e$_2$
    \end{itemize}
  \item ако \tt{s = f e$_1$ e$_2$ \ldots\ e$_n$}, за \tt f $n$-местна примитивна функция:
    \begin{itemize}
    \item оценяват се последователно \tt{e$_1$}, \ldots\ \tt{e$_n$}
    \item прилага се примитивната операция над оценките им
    \end{itemize}
  \item нека сега да допуснем, че \tt{s = f e}
  \item първо се оценява \tt f, за да разберем как да продължим
  \item ако \tt{f x$_1$ \ldots\ x$_n$ | g$_1$ = t$_1$ \ldots\ | g$_k$ = t$_k$} е дефинирана чрез пазачи:
    \begin{itemize}
    \item тогава \tt f се замества с израза: \tt{\textbackslash x$_1$ \ldots\ x$_n$ -> if g$_1$ then t$_1$ else \ldots\ if g$_k$ then t$_k$ else error "..."}

    \end{itemize}
  \item ако \tt f е конструктор (константа), \alert{оценката остава \tt{f e}}
  \item ако \tt{f = \textbackslash p -> t}, където \tt p е образец, редът на оценяване зависи от образеца!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Кога се оценяват изразите при използване на образци?}
  Как се оценява \tt{(\textbackslash p -> t) e}?\pause
  \begin{itemize}[<+->]
  \item ако \tt{p = c} е константа:
    \begin{itemize}
    \item преминава се към оценката на аргумента \tt e
    \item ако се установи че оценката тя съвпада с \tt c, преминава се към оценката на тялото \tt t
    \end{itemize}
  \item ако \tt{p = \_} е анонимният образец:
    \begin{itemize}
    \item преминава се директно към оценката на \tt t \alert{без да се оценява \tt e}
    \end{itemize}
  \item ако \tt{p = x} е променлива:
    \begin{itemize}
    \item преминава се към оценка на израза \tt t \alert{като се въвежда локалната дефиниция \tt{x = e}}
    \end{itemize}
  \item ако \tt{p = (p$_1$,p$_2$,\ldots,p$_n$)}:
    \begin{itemize}
    \item преминава се към оценката на \tt e
    \item ако се установи, че тя е от вида \tt{(e$_1$,e$_2$,\ldots,e$_n$)}, преминава се към оценката на израза \tt{(\textbackslash p$_1$ p$_2$ \ldots\ p$_n$ -> t) e$_1$ e$_2$ \ldots\ e$_n$}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Кога се оценяват изразите при използване на образци?}
  Как се оценява \tt{(\textbackslash p -> t) e}?
  \begin{itemize}[<+->]
  \item ако \tt{p = (p$_h$:p$_t$)}:
    \begin{itemize}
    \item преминава се към оценката на \tt e
    \item ако се установи, че тя е от вида \tt{(e$_h$:e$_t$)}, преминава се към оценката на израза \tt{(\textbackslash p$_h$ p$_t$ -> t) e$_h$ e$_t$}
    \end{itemize}
  \item ако \tt{p = [p$_1$,p$_2$,\ldots,p$_n$]}:
    \begin{itemize}
    \item преминава се към оценката на \tt e
    \item ако се установи, че тя е от вида \tt{[e$_1$,e$_2$,\ldots,e$_n$]}, преминава се към оценката на израза \tt{(\textbackslash p$_1$ p$_2$ \ldots\ p$_n$ -> t) e$_1$ e$_2$ \ldots\ e$_n$}
    \item всъщност е еквивалентно да разгледаме \tt p като \tt{p$_1$:p$_2$:\ldots:p$_n$:[]}
    \end{itemize}
  \item ако има няколко равенства за \tt f с използване на различни образци, се търси кой образец пасва отгоре надолу
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Оценяване в Haskell: пример 1}
\begin{verbatim}
sumFirst (x:xs) (y:ys) = x + y
\end{verbatim}
\pause
\newcommand{\lra}{\onslide<+->$\longrightarrow$}
\begin{tabular}{rl}
  &\tt{\underline{sumFirst} [1..10] [5..50]}\\\pause
  \lra& \tt{(\textbackslash(x:xs) -> \textbackslash(y:ys) -> x + y) \underline{[1..10]} [5..50]}\\
  \lra& \tt{\underline{(\textbackslash(x:xs) -> \textbackslash(y:ys) -> x + y) (1:[2..10])} [5..50]}\\
  \lra& \tt{\lett{x=1; xs=[2..10]}{(\textbackslash(y:ys) -> x + y) \underline{[5..50]}}}\\
  \lra& \tt{\lett{x=1; xs=[2..10]}{\underline{(\textbackslash(y:ys) -> x + y) (5:[6..50])}}}\\
  \lra& \tt{\lett{x=1; xs=[2..10]; y=5; ys=[6..50]}{\underline x+\underline y}}\\
  \lra& \tt{\underline{1 + 5}} \lra\;\tt 6
\end{tabular}
\end{frame}

\begin{frame}
  \frametitle{Оценяване в Haskell: пример 2}
\newcommand{\lra}{\onslide<+->$\longrightarrow$}
\begin{tabular}{r@{ }l@{ }l}
  &\multicolumn 2l{\tt{(filter isPrime [4..1000]) \underline{!!} 1}}\\\pause
  \lra&\multicolumn 2l{\tt{(\textbackslash(x:xs) n -> xs !! (n-1)) \underline{(filter isPrime [4..1000])} 1}}\\
  \lra&\multicolumn 2l{\tt{(\textbackslash(x:xs) n -> xs !! (n-1)) (\underline{filter} isPrime [4..1000]) 1}}\\
  \lra&\ldots\tt{\underline{(\textbackslash p (z:zs) ->}}&\underline{\tt{if p z then z:filter p zs}}\\
  &&\tt{\underline{else filter p zs) isPrime} [4..1000]}\ldots\\
  \lra&\ldots\tt{\lett{p=isPrime}{}}&\tt{(\textbackslash (z:zs) -> if p z then z:filter p zs}\\
  &&\tt{else filter p zs) \underline{[4..1000]}}\ldots\\
  \lra&\ldots\tt{\lett{p=isPrime}{}}&\underline{\tt{(\textbackslash (z:zs) -> if p z then z:filter p zs}}\\
  &&\underline{\tt{else filter p zs) (4:[5..1000]))}}\ldots\\
  \lra&\multicolumn 2{@{}l}{\ldots\tt{\lett{p=isPrime; z=4; zs=[5..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if \underline{p z} then z:filter p zs else filter p zs}\ldots}\\
  \lra&\multicolumn 2{@{}l}{\ldots\tt{\lett{p=isPrime; z=4; zs=[5..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if False then z:filter p zs else \underline{filter p zs}}\ldots}\\
\end{tabular}
\end{frame}

\begin{frame}
  \frametitle{Оценяване в Haskell: пример 2}
\newcommand{\lra}{\onslide<+->$\longrightarrow$}
\begin{tabular}{r@{ }l@{ }l}
  \lra&\ldots\tt{\underline{(\textbackslash p (z:zs) ->}}&\underline{\tt{if p z then z:filter p zs}}\\
  &&\tt{\underline{else filter p zs) isPrime} [5..1000]}\ldots\\
  \lra&\ldots\tt{\lett{p=isPrime}{}}&\underline{\tt{(\textbackslash (z:zs) -> if p z then z:filter p zs}}\\
  &&\underline{\tt{else filter p zs) (5:[6..1000])}}\ldots\\
  \lra&\multicolumn 2{@{}l}{\tt{\ldots \lett{p=isPrime; z=5; zs=[6..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if \underline{p z} then z:filter p zs else filter p zs}\ldots}\\
  \lra&\multicolumn 2{@{}l}{\tt{\ldots \lett{p=isPrime; z=5; zs=[6..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if True then \underline{z:filter p zs} else filter p zs}\ldots}\\
  \lra&\multicolumn 2{@{}l}{\tt{\underline{(\textbackslash(x:xs) n -> xs !! (n-1)) (5:filter isPrime [6..1000])} 1}}\\
  \lra&\multicolumn 2{@{}l}{\tt{\lett{xs=filter isPrime [6..1000]}{}}\underline{\tt{(\textbackslash n -> xs !! (n-1)) 1}}}\\
  \lra&\multicolumn 2{@{}l}{\tt{\lett{xs=filter isPrime [6..1000]; n=1}{xs \underline{!!} (n-1)}}}\\
  \lra&\multicolumn 2{@{}l}{\tt{\underline{(\textbackslash (y:\_) 0 -> y) (filter isPrime [6..1000])} 0}}
\end{tabular}
\end{frame}

\begin{frame}
  \frametitle{Оценяване в Haskell: пример 2}
\newcommand{\lra}{\onslide<+->$\longrightarrow$}
\begin{tabular}{r@{ }l@{ }l}
  \lra&\ldots\tt{\underline{(\textbackslash p (z:zs) ->}}&\underline{\tt{if p z then z:filter p zs}}\\
  &&\tt{\underline{else filter p zs) isPrime} [6..1000]}\ldots\\
  \lra&\ldots\tt{\lett{p=isPrime}{}}&\underline{\tt{(\textbackslash (z:zs) -> if p z then z:filter p zs}}\\
  &&\underline{\tt{else filter p zs) (6:[7..1000])}}\ldots\\
  \lra&\multicolumn 2{@{}l}{\ldots\tt{\lett{p=isPrime; z=6; zs=[7..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if \underline{p z} then z:filter p zs else filter p zs}\ldots}\\
  \lra&\multicolumn 2{@{}l}{\ldots\tt{\lett{p=isPrime; z=6; zs=[7..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if False then z:filter p zs else \underline{filter p zs}}\ldots}\\
  \lra&\ldots\tt{\underline{(\textbackslash p (z:zs) ->}}&\underline{\tt{if p z then z:filter p zs}}\\
  &&\tt{\underline{else filter p zs) isPrime} [7..1000]}\ldots\\
  \lra&\ldots\tt{\lett{p=isPrime}{}}&\underline{\tt{(\textbackslash (z:zs) -> if p z then z:filter p zs}}\\
  &&\underline{\tt{else filter p zs) (7:[8..1000])}}\ldots\\
  \lra&\multicolumn 2{@{}l}{\ldots\tt{\lett{p=isPrime; z=7; zs=[8..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if \underline{p z} then z:filter p zs else filter p zs}\ldots}
\end{tabular}
\end{frame}

\begin{frame}[label=current]
  \frametitle{Оценяване в Haskell: пример 2}
\newcommand{\lra}{\onslide<+->$\longrightarrow$}
\begin{tabular}{r@{ }l@{ }l}
  \lra&\multicolumn 2{@{}l}{\ldots\tt{\lett{p=isPrime; z=7; zs=[8..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if True then \underline{z:filter p} zs else filter p zs} \ldots}\\
  \lra&\multicolumn 2{@{}l}{\underline{\tt{(\textbackslash (y:\_) 0 -> y) (7:filter isPrime [8..1000]) 0}}}\\
  \lra&\multicolumn 2{@{}l}{\tt{\lett{y=7}y}}\\
  \lra&\tt 7
\end{tabular}
\end{frame}

\section{Потоци}

\begin{frame}
  \frametitle{Потоци в Haskell}
  \begin{itemize}[<+->]
  \item Можем да си мислим, че аргументите в Haskell са \textbf{обещания}, които се изпълняват при нужда
  \item В частност, \tt{x:xs = (:) x xs}, където
    \begin{itemize}
    \item \tt x е обещание за глава
    \item \tt{xs} е обещание за опашка
    \end{itemize}
  \item \alert{списъците в Haskell всъщност са потоци!}
  \item можем да работим с безкрайни списъци
    \begin{itemize}
    \item \tt{ones = 1 : ones}
    \item \evalstoinf{length ones}
    \item \evalsto{take 5 ones}{[1,1,1,1,1]}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Генериране на безкрайни списъци}
  \begin{itemize}
  \item \tta[from\tta{..}\tta] $\rightarrow$ \tta[from\tta, from+1\tta, \ldots\tta]
  \item Примери:
    \begin{itemize}
    \item \tt{nats = [0..]}
    \item \evalsto{take 5 [0..]}{[0,1,2,3,4]}
    \item \evalsto{take 26 ['a'..]}{abcdefghijklmnopqrstuvwxyz"}
    \end{itemize}
  \item Синтактична захар за \tt{enumFrom from}
    \pause
  \item \tta[from\tta,from+inc\tta{..}\tta] $\rightarrow$ \tta[from\tta, from+inc\tta, from+2.inc\tta,\ldots\tta]
  \item Примери:
    \begin{itemize}
    \item \tt{evens = [0,2..]}
    \item \evalsto{take 5 evens}{[0,2,4,6,8]}
    \item \evalsto{take 7 ['a','e'..]}{"aeimquy"}
    \end{itemize}
  \item Синтактична захар за \tt{enumFromThen from then}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Генериране на безкрайни списъци}
  \begin{itemize}[<+->]
  \item \tt{repeat :: a -> [a]}
    \begin{itemize}
    \item създава безкрайния списък \tt{[x,x,\ldots]}
    \item \tt{repeat x = x:repeat x}
    \item \tt{replicate n x = take n (repeat x)}
    \end{itemize}
  \item \tt{cycle :: [a] -> [a]}
    \begin{itemize}
    \item \evalsto{cycle [1,2,3]}{[1,2,3,1,2,3,\ldots]}
    \item създава безкраен списък повтарайки подадения (краен) списък
    \end{itemize}
  \item \tt{iterate :: (a -> a) -> a -> [a]}
    \begin{itemize}
    \item \tt{iterate f z} създава безкрайния списък \tt{[z,f(z),f(f(z)),\ldots]}
    \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Отделяне на безкрайни списъци}
  Отделянето на списъци работи и за безкрайни списъци.\pause
  \begin{itemize}[<+->]
  \item \tt{oddSquares = \rvl{[ x\^{}2 | x <- [1,3..] ]}}
  \item \tt{twins = \rvl{[ (x,x+2) | x <- [1..], prime x, prime
        (x+2) ]}}
  \item \tt{pairs = \rvl{[ (x,y) | x <- [0..], y <- [0..x - 1] ]}}
  \item \tt{pythagoreanTriples = \rvl{
        \begin{tabular}[t]{ll}
          [ (a,b,c) | &c <- [1..],\\
                      &b <- [1..c-1],\\
                      &a <- [1..b-1],\\
                      &a\^{}2 + b\^{}2 == c\^{}2 ]
        \end{tabular}}}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Функции от по-висок ред над безкрайни списъци}
  Повечето функции от по-висок ред работят и над безкрайни списъци!
  \begin{itemize}[<+->]
  \item \tt{powers2 = 1 : map (*2) powers2}
  \item \tt{notdiv k = filter (\textbackslash x -> x `mod` k > 0) [1..]}
  \item \tt{fibs = 0:1:zipWith (+) fibs (tail fibs)}
  \item \evalstop{foldr (+) 0 [1..]}{\ldots}
    \begin{itemize}
    \item \alert{Внимание:} \tt{foldr} не работи над безкрайни списъци с операции, които изискват оценка на десния си аргумент!
    \item \tt{triplets = iterate (map (+3)) [3,2,1]}
    \item \evalsto{take 3 triplets}{[[3,2,1],[6,5,4],[9,8,7]]}
    \item \evalstop{take 5 (foldr (++) [] triplets)}{[3,2,1,6,5]}
    \item \evalstop{take 5 (foldl (++) [] triplets)}{\ldots}
    \item \alert{\tt{foldl} не може да работи с безкрайни списъци!}
    \end{itemize}
  \end{itemize}
\end{frame}

\section{Безточково програмиране}

\begin{frame}
  \frametitle{Апликация}
  \begin{itemize}[<+->]
  \item Операцията ``апликация'' се дефинира с \tt{f \$ x = f x}
  \item За какво може да бъде полезна?
  \item Операцията \tt{\$} е с най-нисък прироритет и е дясноасоциативна
    \begin{itemize}
    \item за разлика от прилагането на функции, което е с най-висок приоритет и лявоасоциативно
    \end{itemize}
  \item Може да бъде използвана за спестяване на скоби вложени надясно
  \item \tt{(\ldots((f x$_1$) x$_2$) \ldots x$_n$)} = \tt{f x$_1$ x$_2$ \ldots x$_n$}
  \item \tt{f$_1$ (f$_2$ \ldots (f$_n$ x)\ldots)} = \tt{f$_1$ \$ f$_2$ \$ \ldots \$ f$_n$ \$ x}
  \item Примери:
    \begin{itemize}
    \item \tt{\alt<+->{head \$ tail \$ take 5 \$ drop 7 \$ l}{head (tail (take 5 (drop 7 l)))}}
    \item \tt{\alt<+->{sum \$ map (\^{}2) \$ filter odd \$ [1..10]}{sum (map (\^{}2) (filter odd [1..10]))}}
    \item \evalstop{map (\$2) [(+2),(3\^{}),(*5)]}{[4,9,10]}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Композиция}
  \begin{itemize}[<+->]
  \item \tt{(f . g) x = f (g x)} --- операция ``композиция''
  \item с най-висок приоритет, дясноасоциативна
  \item Може да бъде използвана за спестяване на скоби вложени надясно
  \item \tt{f$_1$ (f$_2$ \ldots (f$_n$ x)\ldots)} = \tt{f$_1$ . f$_2$ . \ldots . f$_n$ \$ x}
  \item Примери:
    \begin{itemize}
    \item \tt{\alt<+->{sublist n m = take m . drop n}{sublist n m l = take m (drop n l)}}
    \item \tt{\alt<+->{sumOddSquares = sum . map (\^{}2) . filter odd}{sumOddSquares l = sum (map (\^{}2) (filter odd l))}}
    \item \tt{repeated n f x = foldr (\$) x (replicate n f)}
    \item \tt{repeated n f = foldr (.) id (replicate n f)}
    \item \tt{repeated n f = foldr (.) id ((replicate n) f)}
    \item \tt{repeated n = foldr (.) id . replicate n}
    \item \tt{repeated n = (foldr (.) id .) (replicate n)}
    \item \tt{repeated = (foldr (.) id .) . replicate}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Безточково (point-free) програмиране}
  С помощта на операциите \tt{\$} и \tt. можем да дефинираме функции чрез директно използване на други функции.\\\pause
  Този стил се нарича \textbf{безточково програмиране}\\\pause
  Пример 1:
  \begin{itemize}[<+->]
    \small
  \item \tt{g l = filter (\textbackslash f -> f 2 > 3) l}
  \item \tt{g = filter (\textbackslash f -> f \$ 2 > 3)}
  \item \tt{g = filter (\textbackslash f -> (>3) ((\$2) f)}
  \item \tt{g = filter \$ (>3) . (\$2)}
  \end{itemize}
  \onslide<+->
  Пример 2:
  \begin{itemize}[<+->]
  \footnotesize
  \item \tt{split3 ll = map (\textbackslash x -> map (\textbackslash f -> filter f x)  [(<0),(==0),(>0)]) ll}
  \item \tt{split3 = map  (\textbackslash x -> map (\textbackslash f -> flip filter x f) [(<0),(==0),(>0)])}
  \item \tt{split3 = map  (\textbackslash x -> map (flip filter x) [(<0),(==0),(>0)])}
  \item \tt{split3 = map  (\textbackslash x -> flip map [(<0),(==0),(>0)] (flip filter x))}
  \item \tt{split3 = map (flip map [(<0),(==0),(>0)] . flip filter)}
  \item \tt{split3 = map \$ flip map [(<0),(==0),(>0)] . flip filter}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Безточково (point-free) програмиране}
  Пример 3:
  \begin{itemize}[<+->]
  \item \tt{sorted l = all (\textbackslash(x,y) -> x <= y) (zip l (tail l))}
  \item \tt{sorted l = all (\textbackslash(x,y) -> (<=) x y) (zip l \$ tail l)}
  \item \tt{sorted l = all (uncurry (<=)) \$ zip l \$ tail l}
  \end{itemize}
  \onslide<+->
  Пример 4:
  \begin{itemize}[<+->]
  \small
  \item \tt{checkMatrix k m = all (\textbackslash r -> any (\textbackslash x -> mod k x > 0)) m}
  \item \tt{checkMatrix k = all (\textbackslash r -> any (\textbackslash x -> mod k x > 0) r)}
  \item \tt{checkMatrix k = all (\textbackslash r -> any (\textbackslash x -> (>0) ((mod k) x)))}
  \item \tt{checkMatrix k = all (\textbackslash r -> any ((>0) . (mod k)) r)}
  \item \tt{checkMatrix k = all (any ((>0) . (mod k)))}
  \item \tt{checkMatrix k = all (any ((.) (>0) (mod k)))}
  \item \tt{checkMatrix k = all . any . ((.)(>0)) . mod \$ k}
  \item \tt{checkMatrix = all . any . ((>0).) . mod}
  \end{itemize}
\end{frame}
\section{Стриктно оценяване}

\begin{frame}
  \frametitle{Разходване на памет при лениво оценяване}
  Ленивото оценяване може да доведе до голям разход на памет.\\[1em]\pause
  В Scheme:
  \begin{itemize}[<+->]
  \item \tt{(define (f x) (f (- 1 x)))}
  \item \evalstop{(f 0)}{\textsf{забива, но не изразходва памет}}
  \item \tt f е \textbf{опашково-рекурсивна} и се реализира чрез итерация
  \item \evalsto{(f 0)}{\evalsto{(f 1)}{\evalsto{(f 0)}{\evalsto{(f 1)}\ldots}}}
  \end{itemize}
  \onslide<+->
  В Haskell:
  \begin{itemize}[<+->]
  \item \tt{f x = f (1-x)}
  \item \evalstop{f 0}{\textsf{\alert{забива с изтичане на памет!}}}
  \item \evalsto{f 0}{\evalsto{f (1-0)}{\evalsto{f (1-(1-0))}{\evalsto{f (1-(1-(1-0)))}\ldots}}}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Стриктно оценяване в Haskell}
  \begin{itemize}[<+->]
  \item в Haskell може да изискаме даден израз да се оцени веднага
  \item еквивалентно на форсиране на обещание
  \item \tt{seq :: a -> b -> b}
  \item оценява първия си аргумент и връща втория като резултат
  \item Примери:
    \begin{itemize}
    \item \tt{second x y = y}
    \item \evalsto{second [1..10\^{}10\^{}10] 2}2
    \item \tt{seq [1..10\^{}10\^{}10] 2} $\xrightarrow{\hspace{35ex}}$ \tt 2
    \item \tt{f x = seq x (f (1-x))}
    \item \evalstop{f 0}{\textsf{забива, но не изразходва памет!}}
    \end{itemize}
  \item \tt{f \$! x = seq x \alt<+->{\$ f x}{(f x)}}
    \begin{itemize}
    \item първо оценява \tt x и след това прилага \tt f над оценката на \tt x
    \item прилага \tt f над \tt x със стриктно оценяване
    \item \tt{f x = f \$! (1-x)}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Изразходване на памет при \tt{foldl}}
  \newcommand{\lra}{\onslide<+->$\longrightarrow$}
  \begin{tabular}{rl}
    &\tt{foldl (+) 0 [1..4]}\\
    \pause
   \lra&\tt{foldl (+) (0 + 1) [2..4]}\\
   \lra&\tt{foldl (+) ((0 + 1) + 2) [3..4]}\\
   \lra&\tt{foldl (+) (((0 + 1) + 2) + 3) [4..4]}\\
   \lra&\tt{foldl (+) ((((0 + 1) + 2) + 3) + 4) []}\\
   \lra&\tt{((((0 + 1) + 2) + 3) + 4)}\\
   \lra&\tt{(((1 + 2) + 3) + 4)}\\
   \lra&\tt{((3 + 3) + 4)}\\
   \lra&\tt{(6 + 4)}\\
   \lra&\tt{10}
  \end{tabular}\\[2em]
  \onslide<+->
  \alert{Проблем:} Изразходва памет при оценяване, понеже отлага изчисления!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Стриктен вариант на \tt{foldl}}
  \newcommand{\lra}{\onslide<+->$\longrightarrow$}
  \onslide<+->
\begin{verbatim}
foldl' _ nv [] = nv
foldl' op nv (x:xs) = (foldl' op $! op nv x) xs
\end{verbatim}
  \onslide<+->
  \begin{tabular}{rl}
    &\tt{foldl' (+) 0 [1..4]}\\
   \lra&\tt{foldl' (+) 1 [2..4]}\\
   \lra&\tt{foldl' (+) 3 [3..4]}\\
   \lra&\tt{foldl' (+) 6 [4..4]}\\
   \lra&\tt{foldl' (+) 10 []}\\
   \lra&\tt{10}
  \end{tabular}
\end{frame}

\end{document}
