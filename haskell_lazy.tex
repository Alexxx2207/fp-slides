\documentclass{beamer}
\usepackage{fprog}

\title[Лениво оценяване]{Лениво оценяване и програмиране от по-висок ред}

\date{7 януари 2016 г.}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

%\includeonlyframes{current}

\section{Лениво оценяване}

\begin{frame}
  \frametitle{Щипка $\lambda$-смятане}
  \newcommand{\lra}{\rightarrow}
  \begin{itemize}[<+->]
  \item $\lambda$-изрази: $E ::= x \;|\; E_1(E_2) \;|\; \lambda x\, E$
  \item Изчислително правило: $(\lambda x\,E_1)(E_2) \mapsto E_1[x := E_2]$
  \item В какъв ред прилагаме изчислителното правило?
  \item Нека $f := \lambda x\; x!$, $g := \lambda z\;z^2+z$
  \item $g(f(4)) \lra \quad ?$
  \item $g(\underline{f(4)})
    \onslide<+->
    \lra g(\underline{4!})
    \onslide<+->
    \lra \underline{g(24)}
    \onslide<+->
    \lra 24^2 + 24
    \onslide<+->
    \lra 600$
    \begin{itemize}
    \item<16-> оценяваме \alert{отвътре навън}
    \item<17-> \alert{стриктно} (апликативно, лакомо) оценяване
    \end{itemize}
  \item $\underline{g(f(4))}
    \onslide<+->
    \lra \underline{(f(4))}^2 + \underline{f(4)}
    \onslide<+->
    \lra (\underline{4!})^2 + \underline{4!}
    \onslide<+->
    \lra 24^2 + 24
    \onslide<+->
    \lra 600$
    \begin{itemize}
    \item<16-> оценяваме \alert{отвън навътре}
    \item<17-> \alert{нестриктно} (нормално, лениво) оценяване
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Стриктно и нестриктно оценяване}
  Стриктното оценяване
  \begin{itemize}[<+->]
  \item се използва в повечето езици за програмиране
  \item се нарича още ``call-by-value'' (извикване по стойност)
  \item позволява лесно да се контролира реда на изпълнение
  \item пестеливо откъм памет, понеже ``пази чисто''
  \end{itemize}
  \onslide<+->
  Нестриктното оценяване
  \begin{itemize}[<+->]
  \item е по-рядко използвано
  \item въпреки това се среща в някаква форма в повечето езици!
    \begin{itemize}
    \item \tt{x = p != NULL ? p->data : 0;}
    \item \tt{found = i < n \&\& a[i] == x}
    \end{itemize}
  \item нарича се още ``call-by-name'' (извикване по име)
  \item може да спести сметки, понеже ``изхвърля боклуците''
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Кога мързелът помага}
  \newcommand{\lra}{$\;\rightarrow\;$}
\begin{verbatim}
(define (f x y) (if (< x 5) x y)
(define (g l)   (f (car l) (cadr l)))
\end{verbatim}
\pause
\begin{tabular}[t]{l@{}l}
\tt{\underline{(g '(3))}}
\pause
&\lra \tt{(f \underline{(car '(3))} (cadr '(3)))}\\
\pause
&\lra \tt{(f 3 \underline{(cadr '(3))})}
\pause
\lra \alert{Грешка!}
\end{tabular}
\pause
\begin{verbatim}
f x y = if x < 5 then x else y
g l   = f (head l) (head (tail l))
\end{verbatim}
\pause
\begin{tabular}[t]{l@{}l}
\tt{\underline{g [3]}}
\pause
&\lra \tt{\underline{f (head [3]) (head (tail [3]))}}\\
\pause
&\lra \tt{if \underline{head [3]} < 5 then head [3] else head (tail [3])}\\
\pause
&\lra \tt{if \underline{3 < 5} then head [3] else head (tail [3])}\\
\pause
&\lra \tt{\underline{if True then head [3] else head (tail [3])}}\\
\pause
&\lra \tt{\underline{head [3]}}
\pause
\lra \tt 3
\end{tabular}
\end{frame}

\begin{frame}
  \frametitle{Теорема за нормализация}
  \begin{itemize}[<+->]
  \item всеки път когато апликативното оценяване дава резултат и нормалното оценяване дава резултат
  \item има случаи, когато нормалното оценяване дава резултат, но апликативното не!
  \item нещо повече:
  \end{itemize}
  \onslide<.->
  \begin{theorem}[за нормализация, Church-Rosser]
    Ако има някакъв ред на оценяване на програмата, който достига до резултат, то и с нормална стратегия на оценяване ще достигнем до някакъв резултат.
  \end{theorem}
  \onslide<+->
  \begin{corollary}
    Ако с нормално оценяване програмата даде грешка или не завърши, то няма да получим резултат с \alert{никоя друга стратегия на оценяване}.
  \end{corollary}
\end{frame}

\begin{frame}
  \frametitle{Извикване при нужда (``call-by-need'')}

Ако $g(z) = z^2 + z$, $g(g(g(2))) = ?$
\pause
\begin{equation*}
  \begin{array}{rl}
  g(g(g(2))) \pause &\mapsto g(g(2))^2 + g(g(2)) \pause\mapsto (g(2)^2+ g(2))^2 + g(2)^2 + g(2) \pause\mapsto\\
  &\mapsto ((2^2+2)^2+2^2+2)+(2^2+2)^2 + 2^2+2 \mapsto \ldots
  \end{array}
\end{equation*}\pause
Времето и паметта нарастват експоненциално!\\
\pause
\fbox{\textbf{Идея:} $(\lambda x\,E_1)(E_2) \mapsto \lett{x = E_2}{E_1}$}
\pause
\begin{equation*}
  \begin{array}{rl}
    g(g(g(2))) \pause &\mapsto \lett{x = g(g(2))}{x^2 + x}\pause \mapsto\\
    &\mapsto \lett{y=g(2)}{\lett{x=y^2+y}{x^2 + x}} \pause \mapsto\\
    &\mapsto \lett{z=2}{\lett{y=z^2+z}{\lett{x=y^2+y}{x^2 + x}}} \pause \mapsto\\
    &\mapsto \lett{y=6}{\lett{x = y^2+y}{x^2 + x}} \pause \mapsto\\
    &\mapsto \lett{x=42}{x^2 + x} \mapsto 1806
  \end{array}
\end{equation*}\pause\vspace{-1.5em}
\begin{itemize}[<+->]
\item Избягва се повторението чрез споделяне на общи подизрази
\item Заместването се извършва чак когато е \alert{абсолютно наложително}
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Кога се налага оценяване на израз?}
  Във всеки даден момент Haskell оценява някой израз \tt s. \pause
  \begin{itemize}[<+->]
  \item ако \tt{s = if e then e$_1$ else e$_2$}
    \begin{itemize}
    \item първо се оценява \tt e
    \item ако оценката е \tt{True}, се преминава към оценката на e$_1$
    \item ако оценката е \tt{False}, се преминава към оценката на e$_2$
    \end{itemize}
  \item ако \tt{s = f e$_1$ e$_2$ \ldots\ e$_n$}, за \tt f $n$-местна примитивна функция:
    \begin{itemize}
    \item оценяваме последователно \tt{e$_1$}, \ldots\ \tt{e$_n$}
    \item прилагаме примитивната операция над оценките им
    \end{itemize}
  \item нека сега да допуснем, че \tt{s = f e}
  \item първо се оценява \tt f, за да разберем как да продължим
  \item ако \tt{f x$_1$ \ldots\ x$_n$ | g$_1$ = t$_1$ \ldots\ | g$_k$ = t$_k$} е дефинирана чрез пазачи:
    \begin{itemize}
    \item тогава заместваме \tt f със израза: \tt{\textbackslash x$_1$ \ldots\ x$_n$ -> if g$_1$ then t$_1$ else \ldots\ if g$_k$ then t$_k$ else error "..."}

    \end{itemize}
  \item ако \tt f е конструктор (константа), \alert{оценката остава \tt{f e}}
  \item ако \tt{f = \textbackslash p -> t}, където \tt p е образец, редът на оценяване зависи от образеца!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Кога се оценяват изразите при използване на образци?}
  Как се оценява \tt{(\textbackslash p -> t) e}?\pause
  \begin{itemize}[<+->]
  \item ако \tt{p = c} е константа:
    \begin{itemize}
    \item преминава се към оценката на аргумента \tt e
    \item ако се установи че оценката тя съвпада с \tt c, преминава се към оценката на тялото \tt t
    \end{itemize}
  \item ако \tt{p = \_} е анонимният образец:
    \begin{itemize}
    \item преминава се директно към оценката на \tt t \alert{без да се оценява \tt e}
    \end{itemize}
  \item ако \tt{p = x} е променлива:
    \begin{itemize}
    \item преминава се към оценка на израза \tt t \alert{като се въвежда локалната дефиниция \tt{x = e}}
    \end{itemize}
  \item ако \tt{p = (p$_1$,p$_2$,\ldots,p$_n$)}:
    \begin{itemize}
    \item преминава се към оценката на \tt e
    \item ако се установи, че тя е от вида \tt{(e$_1$,e$_2$,\ldots,e$_n$)}, преминава се към оценката на израза \tt{(\textbackslash p$_1$ p$_2$ \ldots\ p$_n$ -> t) e$_1$ e$_2$ \ldots\ e$_n$}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Кога се оценяват изразите при използване на образци?}
  Как се оценява \tt{(\textbackslash p -> t) e}?
  \begin{itemize}[<+->]
  \item ако \tt{p = (p$_h$:p$_t$)}:
    \begin{itemize}
    \item преминава се към оценката на \tt e
    \item ако се установи, че тя е от вида \tt{(e$_h$:e$_t$)}, преминава се към оценката на израза \tt{(\textbackslash p$_h$ p$_t$ -> t) e$_h$ e$_t$}
    \end{itemize}
  \item ако \tt{p = [p$_1$,p$_2$,\ldots,p$_n$]}:
    \begin{itemize}
    \item преминава се към оценката на \tt e
    \item ако се установи, че тя е от вида \tt{[e$_1$,e$_2$,\ldots,e$_n$]}, преминава се към оценката на израза \tt{(\textbackslash p$_1$ p$_2$ \ldots\ p$_n$ -> t) e$_1$ e$_2$ \ldots\ e$_n$}
    \item всъщност е еквивалентно да разгледаме \tt p като \tt{p$_1$:p$_2$:\ldots:p$_n$:[]}
    \end{itemize}
  \item ако има няколко равенства за \tt f с използване на различни образци, се търси кой образец пасва отгоре надолу
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Оценяване в Haskell: пример 1}
\begin{verbatim}
sumFirst (x:xs) (y:ys) = x + y
\end{verbatim}
\pause
\newcommand{\lra}{\onslide<+->$\longrightarrow$}
\begin{tabular}{rl}
  &\tt{\underline{sumFirst} [1..10] [5..50]}\\\pause
  \lra& \tt{(\textbackslash(x:xs) -> \textbackslash(y:ys) -> x + y) \underline{[1..10]} [5..50]}\\
  \lra& \tt{\underline{(\textbackslash(x:xs) -> \textbackslash(y:ys) -> x + y) (1:[2..10])} [5..50]}\\
  \lra& \tt{\lett{x=1; xs=[2..10]}{(\textbackslash(y:ys) -> x + y) \underline{[5..50]}}}\\
  \lra& \tt{\lett{x=1; xs=[2..10]}{\underline{(\textbackslash(y:ys) -> x + y) (5:[6..50])}}}\\
  \lra& \tt{\lett{x=1; xs=[2..10]; y=5; ys=[6..50]}{\underline x+\underline y}}\\
  \lra& \tt{\underline{1 + 5}} \lra\;\tt 6
\end{tabular}
\end{frame}

\begin{frame}
  \frametitle{Оценяване в Haskell: пример 2}
\newcommand{\lra}{\onslide<+->$\longrightarrow$}
\begin{tabular}{r@{ }l@{ }l}
  &\multicolumn 2l{\tt{(filter isPrime [4..1000]) \underline{!!} 1}}\\\pause
  \lra&\multicolumn 2l{\tt{(\textbackslash(x:xs) n -> xs !! (n-1)) \underline{(filter isPrime [4..1000]) 1}}}\\
  \lra&\multicolumn 2l{\tt{(\textbackslash(x:xs) n -> xs !! (n-1)) (\underline{filter} isPrime [4..1000]) 1}}\\
  \lra&\tt{\ldots \underline{(\textbackslash p (z:zs) ->}}&\underline{\tt{if p z then z:filter p zs}}\\
  &&\tt{\underline{else filter p zs) isPrime} [4..1000] \ldots}\\
  \lra&\tt{\ldots \lett{p=isPrime}{}}&\tt{(\textbackslash (z:zs) -> if p z then z:filter p zs}\\
  &&\tt{else filter p zs) \underline{[4..1000]} \ldots}\\
  \lra&\tt{\ldots \lett{p=isPrime}{}}&\underline{\tt{(\textbackslash (z:zs) -> if p z then z:filter p zs}}\\
  &&\underline{\tt{else filter p zs) (4:[5..1000])} \ldots}\\
  \lra&\multicolumn 2{@{}l}{\tt{\ldots \lett{p=isPrime; z=4; zs=[5..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if \underline{p z} then z:filter p zs else filter p zs \ldots}}\\
  \lra&\multicolumn 2{@{}l}{\tt{\ldots \lett{p=isPrime; z=4; zs=[5..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if False then z:filter p zs else \underline{filter p zs} \ldots}}\\
\end{tabular}
\end{frame}

\begin{frame}
  \frametitle{Оценяване в Haskell: пример 2}
\newcommand{\lra}{\onslide<+->$\longrightarrow$}
\begin{tabular}{r@{ }l@{ }l}
  \lra&\tt{\ldots \underline{(\textbackslash p (z:zs) ->}}&\underline{\tt{if p z then z:filter p zs}}\\
  &&\tt{\underline{else filter p zs) isPrime} [5..1000] \ldots}\\
  \lra&\tt{\ldots \lett{p=isPrime}{}}&\underline{\tt{(\textbackslash (z:zs) -> if p z then z:filter p zs}}\\
  &&\underline{\tt{else filter p zs) (5:[6..1000])} \ldots}\\
  \lra&\multicolumn 2{@{}l}{\tt{\ldots \lett{p=isPrime; z=5; zs=[6..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if \underline{p z} then z:filter p zs else filter p zs \ldots}}\\
  \lra&\multicolumn 2{@{}l}{\tt{\ldots \lett{p=isPrime; z=5; zs=[6..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{\underline{if True then z:filter p zs else filter p zs}} \ldots}\\
  \lra&\multicolumn 2{@{}l}{\tt{\underline{(\textbackslash(x:xs) n -> xs !! (n-1)) (5:filter isPrime [6..1000])} 1}}\\
  \lra&\multicolumn 2{@{}l}{\tt{\lett{xs=filter isPrime [6..1000]}{}}\underline{\tt{(\textbackslash n -> xs !! (n-1)) 1}}}\\
  \lra&\multicolumn 2{@{}l}{\tt{\lett{xs=filter isPrime [6..1000]; n=1}{xs \underline{!!} (n-1)}}}\\
  \lra&\multicolumn 2{@{}l}{\tt{\underline{(\textbackslash (y:\_) 0 -> y) (filter isPrime [6..1000])} 0}}
\end{tabular}
\end{frame}

\begin{frame}
  \frametitle{Оценяване в Haskell: пример 2}
\newcommand{\lra}{\onslide<+->$\longrightarrow$}
\begin{tabular}{r@{ }l@{ }l}
  \lra&\tt{\ldots \underline{(\textbackslash p (z:zs) ->}}&\underline{\tt{if p z then z:filter p zs}}\\
  &&\tt{\underline{else filter p zs) isPrime} [6..1000] \ldots}\\
  \lra&\tt{\ldots \lett{p=isPrime}{}}&\underline{\tt{(\textbackslash (z:zs) -> if p z then z:filter p zs}}\\
  &&\underline{\tt{else filter p zs) (6:[7..1000])} \ldots}\\
  \lra&\multicolumn 2{@{}l}{\tt{\ldots \lett{p=isPrime; z=6; zs=[7..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if \underline{p z} then z:filter p zs else filter p zs \ldots}}\\
  \lra&\multicolumn 2{@{}l}{\tt{\ldots \lett{p=isPrime; z=6; zs=[7..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if False then z:filter p zs else \underline{filter p zs}} \ldots}\\
  \lra&\tt{\ldots \underline{(\textbackslash p (z:zs) ->}}&\underline{\tt{if p z then z:filter p zs}}\\
  &&\tt{\underline{else filter p zs) isPrime} [7..1000] \ldots}\\
  \lra&\tt{\ldots \lett{p=isPrime}{}}&\underline{\tt{(\textbackslash (z:zs) -> if p z then z:filter p zs}}\\
  &&\underline{\tt{else filter p zs) (7:[8..1000])} \ldots}\\
  \lra&\multicolumn 2{@{}l}{\tt{\ldots \lett{p=isPrime; z=7; zs=[8..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if \underline{p z} then z:filter p zs else filter p zs \ldots}}
\end{tabular}
\end{frame}

\begin{frame}[label=current]
  \frametitle{Оценяване в Haskell: пример 2}
\newcommand{\lra}{\onslide<+->$\longrightarrow$}
\begin{tabular}{r@{ }l@{ }l}
  \lra&\multicolumn 2{@{}l}{\tt{\ldots \lett{p=isPrime; z=7; zs=[8..1000]}{}}}\\
  &\multicolumn 2{@{}l}{\tt{if True then z:filter p zs else filter p zs} \ldots}\\
  \lra&\multicolumn 2{@{}l}{\underline{\tt{(\textbackslash (y:\_) 0 -> y) (7:filter isPrime [8..1000]) 0}}}\\
  \lra&\multicolumn 2{@{}l}{\tt{\lett{y=7}y}}\\
  \lra&\tt 7
\end{tabular}
\end{frame}


\end{document}
